type AffectedRowsOutput {
  count: Int!
}

type AggregateChampion {
  _avg: ChampionAvgAggregate
  _count: ChampionCountAggregate
  _max: ChampionMaxAggregate
  _min: ChampionMinAggregate
  _sum: ChampionSumAggregate
}

type AggregateChampionStat {
  _avg: ChampionStatAvgAggregate
  _count: ChampionStatCountAggregate
  _max: ChampionStatMaxAggregate
  _min: ChampionStatMinAggregate
  _sum: ChampionStatSumAggregate
}

type AggregateGame {
  _avg: GameAvgAggregate
  _count: GameCountAggregate
  _max: GameMaxAggregate
  _min: GameMinAggregate
  _sum: GameSumAggregate
}

type AggregateItem {
  _avg: ItemAvgAggregate
  _count: ItemCountAggregate
  _max: ItemMaxAggregate
  _min: ItemMinAggregate
  _sum: ItemSumAggregate
}

type AggregatePeriod {
  _avg: PeriodAvgAggregate
  _count: PeriodCountAggregate
  _max: PeriodMaxAggregate
  _min: PeriodMinAggregate
  _sum: PeriodSumAggregate
}

type AggregatePlayerStat {
  _avg: PlayerStatAvgAggregate
  _count: PlayerStatCountAggregate
  _max: PlayerStatMaxAggregate
  _min: PlayerStatMinAggregate
  _sum: PlayerStatSumAggregate
}

type AggregateStat {
  _avg: StatAvgAggregate
  _count: StatCountAggregate
  _max: StatMaxAggregate
  _min: StatMinAggregate
  _sum: StatSumAggregate
}

type AggregateSumSpells {
  _avg: SumSpellsAvgAggregate
  _count: SumSpellsCountAggregate
  _max: SumSpellsMaxAggregate
  _min: SumSpellsMinAggregate
  _sum: SumSpellsSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type Champion {
  _count: ChampionCount
  createdAt: DateTime!
  id: Int!
  name: String!
  players(cursor: PlayerStatWhereUniqueInput, distinct: [PlayerStatScalarFieldEnum!], orderBy: [PlayerStatOrderByWithRelationInput!], skip: Int, take: Int, where: PlayerStatWhereInput): [PlayerStat!]!
  stats(cursor: ChampionStatWhereUniqueInput, distinct: [ChampionStatScalarFieldEnum!], orderBy: [ChampionStatOrderByWithRelationInput!], skip: Int, take: Int, where: ChampionStatWhereInput): [ChampionStat!]!
  updatedAt: DateTime!
}

type ChampionAvgAggregate {
  id: Float
}

input ChampionAvgOrderByAggregateInput {
  id: SortOrder
}

type ChampionCount {
  players: Int!
  stats: Int!
}

type ChampionCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input ChampionCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ChampionCreateInput {
  createdAt: DateTime
  name: String!
  players: PlayerStatCreateNestedManyWithoutChampionInput
  stats: ChampionStatCreateNestedManyWithoutChampionInput
  updatedAt: DateTime
}

input ChampionCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input ChampionCreateNestedOneWithoutPlayersInput {
  connect: ChampionWhereUniqueInput
  connectOrCreate: ChampionCreateOrConnectWithoutPlayersInput
  create: ChampionCreateWithoutPlayersInput
}

input ChampionCreateNestedOneWithoutStatsInput {
  connect: ChampionWhereUniqueInput
  connectOrCreate: ChampionCreateOrConnectWithoutStatsInput
  create: ChampionCreateWithoutStatsInput
}

input ChampionCreateOrConnectWithoutPlayersInput {
  create: ChampionCreateWithoutPlayersInput!
  where: ChampionWhereUniqueInput!
}

input ChampionCreateOrConnectWithoutStatsInput {
  create: ChampionCreateWithoutStatsInput!
  where: ChampionWhereUniqueInput!
}

input ChampionCreateWithoutPlayersInput {
  createdAt: DateTime
  name: String!
  stats: ChampionStatCreateNestedManyWithoutChampionInput
  updatedAt: DateTime
}

input ChampionCreateWithoutStatsInput {
  createdAt: DateTime
  name: String!
  players: PlayerStatCreateNestedManyWithoutChampionInput
  updatedAt: DateTime
}

type ChampionGroupBy {
  _avg: ChampionAvgAggregate
  _count: ChampionCountAggregate
  _max: ChampionMaxAggregate
  _min: ChampionMinAggregate
  _sum: ChampionSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

type ChampionMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input ChampionMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type ChampionMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input ChampionMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ChampionOrderByWithAggregationInput {
  _avg: ChampionAvgOrderByAggregateInput
  _count: ChampionCountOrderByAggregateInput
  _max: ChampionMaxOrderByAggregateInput
  _min: ChampionMinOrderByAggregateInput
  _sum: ChampionSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ChampionOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  players: PlayerStatOrderByRelationAggregateInput
  stats: ChampionStatOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input ChampionRelationFilter {
  is: ChampionWhereInput
  isNot: ChampionWhereInput
}

enum ChampionScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input ChampionScalarWhereWithAggregatesInput {
  AND: [ChampionScalarWhereWithAggregatesInput!]
  NOT: [ChampionScalarWhereWithAggregatesInput!]
  OR: [ChampionScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ChampionStat {
  _count: ChampionStatCount
  champion: Champion!
  championId: Int!
  createdAt: DateTime!
  id: Int!
  period: Period!
  periodId: Int!
  support: Boolean!
  updatedAt: DateTime!
  userStats(cursor: StatWhereUniqueInput, distinct: [StatScalarFieldEnum!], orderBy: [StatOrderByWithRelationInput!], skip: Int, take: Int, where: StatWhereInput): [Stat!]!
  winrate: Float!
}

type ChampionStatAvgAggregate {
  championId: Float
  id: Float
  periodId: Float
  winrate: Float
}

input ChampionStatAvgOrderByAggregateInput {
  championId: SortOrder
  id: SortOrder
  periodId: SortOrder
  winrate: SortOrder
}

type ChampionStatCount {
  userStats: Int!
}

type ChampionStatCountAggregate {
  _all: Int!
  championId: Int!
  createdAt: Int!
  id: Int!
  periodId: Int!
  support: Int!
  updatedAt: Int!
  winrate: Int!
}

input ChampionStatCountOrderByAggregateInput {
  championId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  periodId: SortOrder
  support: SortOrder
  updatedAt: SortOrder
  winrate: SortOrder
}

input ChampionStatCreateInput {
  champion: ChampionCreateNestedOneWithoutStatsInput!
  createdAt: DateTime
  period: PeriodCreateNestedOneWithoutChampionStatsInput!
  support: Boolean!
  updatedAt: DateTime
  userStats: StatCreateNestedManyWithoutChampionInput
  winrate: Float!
}

input ChampionStatCreateManyChampionInput {
  createdAt: DateTime
  id: Int
  periodId: Int!
  support: Boolean!
  updatedAt: DateTime
  winrate: Float!
}

input ChampionStatCreateManyChampionInputEnvelope {
  data: [ChampionStatCreateManyChampionInput!]!
  skipDuplicates: Boolean
}

input ChampionStatCreateManyInput {
  championId: Int!
  createdAt: DateTime
  id: Int
  periodId: Int!
  support: Boolean!
  updatedAt: DateTime
  winrate: Float!
}

input ChampionStatCreateManyPeriodInput {
  championId: Int!
  createdAt: DateTime
  id: Int
  support: Boolean!
  updatedAt: DateTime
  winrate: Float!
}

input ChampionStatCreateManyPeriodInputEnvelope {
  data: [ChampionStatCreateManyPeriodInput!]!
  skipDuplicates: Boolean
}

input ChampionStatCreateNestedManyWithoutChampionInput {
  connect: [ChampionStatWhereUniqueInput!]
  connectOrCreate: [ChampionStatCreateOrConnectWithoutChampionInput!]
  create: [ChampionStatCreateWithoutChampionInput!]
  createMany: ChampionStatCreateManyChampionInputEnvelope
}

input ChampionStatCreateNestedManyWithoutPeriodInput {
  connect: [ChampionStatWhereUniqueInput!]
  connectOrCreate: [ChampionStatCreateOrConnectWithoutPeriodInput!]
  create: [ChampionStatCreateWithoutPeriodInput!]
  createMany: ChampionStatCreateManyPeriodInputEnvelope
}

input ChampionStatCreateNestedOneWithoutUserStatsInput {
  connect: ChampionStatWhereUniqueInput
  connectOrCreate: ChampionStatCreateOrConnectWithoutUserStatsInput
  create: ChampionStatCreateWithoutUserStatsInput
}

input ChampionStatCreateOrConnectWithoutChampionInput {
  create: ChampionStatCreateWithoutChampionInput!
  where: ChampionStatWhereUniqueInput!
}

input ChampionStatCreateOrConnectWithoutPeriodInput {
  create: ChampionStatCreateWithoutPeriodInput!
  where: ChampionStatWhereUniqueInput!
}

input ChampionStatCreateOrConnectWithoutUserStatsInput {
  create: ChampionStatCreateWithoutUserStatsInput!
  where: ChampionStatWhereUniqueInput!
}

input ChampionStatCreateWithoutChampionInput {
  createdAt: DateTime
  period: PeriodCreateNestedOneWithoutChampionStatsInput!
  support: Boolean!
  updatedAt: DateTime
  userStats: StatCreateNestedManyWithoutChampionInput
  winrate: Float!
}

input ChampionStatCreateWithoutPeriodInput {
  champion: ChampionCreateNestedOneWithoutStatsInput!
  createdAt: DateTime
  support: Boolean!
  updatedAt: DateTime
  userStats: StatCreateNestedManyWithoutChampionInput
  winrate: Float!
}

input ChampionStatCreateWithoutUserStatsInput {
  champion: ChampionCreateNestedOneWithoutStatsInput!
  createdAt: DateTime
  period: PeriodCreateNestedOneWithoutChampionStatsInput!
  support: Boolean!
  updatedAt: DateTime
  winrate: Float!
}

type ChampionStatGroupBy {
  _avg: ChampionStatAvgAggregate
  _count: ChampionStatCountAggregate
  _max: ChampionStatMaxAggregate
  _min: ChampionStatMinAggregate
  _sum: ChampionStatSumAggregate
  championId: Int!
  createdAt: DateTime!
  id: Int!
  periodId: Int!
  support: Boolean!
  updatedAt: DateTime!
  winrate: Float!
}

input ChampionStatListRelationFilter {
  every: ChampionStatWhereInput
  none: ChampionStatWhereInput
  some: ChampionStatWhereInput
}

type ChampionStatMaxAggregate {
  championId: Int
  createdAt: DateTime
  id: Int
  periodId: Int
  support: Boolean
  updatedAt: DateTime
  winrate: Float
}

input ChampionStatMaxOrderByAggregateInput {
  championId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  periodId: SortOrder
  support: SortOrder
  updatedAt: SortOrder
  winrate: SortOrder
}

type ChampionStatMinAggregate {
  championId: Int
  createdAt: DateTime
  id: Int
  periodId: Int
  support: Boolean
  updatedAt: DateTime
  winrate: Float
}

input ChampionStatMinOrderByAggregateInput {
  championId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  periodId: SortOrder
  support: SortOrder
  updatedAt: SortOrder
  winrate: SortOrder
}

input ChampionStatOrderByRelationAggregateInput {
  _count: SortOrder
}

input ChampionStatOrderByWithAggregationInput {
  _avg: ChampionStatAvgOrderByAggregateInput
  _count: ChampionStatCountOrderByAggregateInput
  _max: ChampionStatMaxOrderByAggregateInput
  _min: ChampionStatMinOrderByAggregateInput
  _sum: ChampionStatSumOrderByAggregateInput
  championId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  periodId: SortOrder
  support: SortOrder
  updatedAt: SortOrder
  winrate: SortOrder
}

input ChampionStatOrderByWithRelationInput {
  champion: ChampionOrderByWithRelationInput
  championId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  period: PeriodOrderByWithRelationInput
  periodId: SortOrder
  support: SortOrder
  updatedAt: SortOrder
  userStats: StatOrderByRelationAggregateInput
  winrate: SortOrder
}

input ChampionStatRelationFilter {
  is: ChampionStatWhereInput
  isNot: ChampionStatWhereInput
}

enum ChampionStatScalarFieldEnum {
  championId
  createdAt
  id
  periodId
  support
  updatedAt
  winrate
}

input ChampionStatScalarWhereInput {
  AND: [ChampionStatScalarWhereInput!]
  NOT: [ChampionStatScalarWhereInput!]
  OR: [ChampionStatScalarWhereInput!]
  championId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  periodId: IntFilter
  support: BoolFilter
  updatedAt: DateTimeFilter
  winrate: FloatFilter
}

input ChampionStatScalarWhereWithAggregatesInput {
  AND: [ChampionStatScalarWhereWithAggregatesInput!]
  NOT: [ChampionStatScalarWhereWithAggregatesInput!]
  OR: [ChampionStatScalarWhereWithAggregatesInput!]
  championId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  periodId: IntWithAggregatesFilter
  support: BoolWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  winrate: FloatWithAggregatesFilter
}

type ChampionStatSumAggregate {
  championId: Int
  id: Int
  periodId: Int
  winrate: Float
}

input ChampionStatSumOrderByAggregateInput {
  championId: SortOrder
  id: SortOrder
  periodId: SortOrder
  winrate: SortOrder
}

input ChampionStatUpdateInput {
  champion: ChampionUpdateOneRequiredWithoutStatsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  period: PeriodUpdateOneRequiredWithoutChampionStatsNestedInput
  support: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userStats: StatUpdateManyWithoutChampionNestedInput
  winrate: FloatFieldUpdateOperationsInput
}

input ChampionStatUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  support: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  winrate: FloatFieldUpdateOperationsInput
}

input ChampionStatUpdateManyWithWhereWithoutChampionInput {
  data: ChampionStatUpdateManyMutationInput!
  where: ChampionStatScalarWhereInput!
}

input ChampionStatUpdateManyWithWhereWithoutPeriodInput {
  data: ChampionStatUpdateManyMutationInput!
  where: ChampionStatScalarWhereInput!
}

input ChampionStatUpdateManyWithoutChampionNestedInput {
  connect: [ChampionStatWhereUniqueInput!]
  connectOrCreate: [ChampionStatCreateOrConnectWithoutChampionInput!]
  create: [ChampionStatCreateWithoutChampionInput!]
  createMany: ChampionStatCreateManyChampionInputEnvelope
  delete: [ChampionStatWhereUniqueInput!]
  deleteMany: [ChampionStatScalarWhereInput!]
  disconnect: [ChampionStatWhereUniqueInput!]
  set: [ChampionStatWhereUniqueInput!]
  update: [ChampionStatUpdateWithWhereUniqueWithoutChampionInput!]
  updateMany: [ChampionStatUpdateManyWithWhereWithoutChampionInput!]
  upsert: [ChampionStatUpsertWithWhereUniqueWithoutChampionInput!]
}

input ChampionStatUpdateManyWithoutPeriodNestedInput {
  connect: [ChampionStatWhereUniqueInput!]
  connectOrCreate: [ChampionStatCreateOrConnectWithoutPeriodInput!]
  create: [ChampionStatCreateWithoutPeriodInput!]
  createMany: ChampionStatCreateManyPeriodInputEnvelope
  delete: [ChampionStatWhereUniqueInput!]
  deleteMany: [ChampionStatScalarWhereInput!]
  disconnect: [ChampionStatWhereUniqueInput!]
  set: [ChampionStatWhereUniqueInput!]
  update: [ChampionStatUpdateWithWhereUniqueWithoutPeriodInput!]
  updateMany: [ChampionStatUpdateManyWithWhereWithoutPeriodInput!]
  upsert: [ChampionStatUpsertWithWhereUniqueWithoutPeriodInput!]
}

input ChampionStatUpdateOneWithoutUserStatsNestedInput {
  connect: ChampionStatWhereUniqueInput
  connectOrCreate: ChampionStatCreateOrConnectWithoutUserStatsInput
  create: ChampionStatCreateWithoutUserStatsInput
  delete: Boolean
  disconnect: Boolean
  update: ChampionStatUpdateWithoutUserStatsInput
  upsert: ChampionStatUpsertWithoutUserStatsInput
}

input ChampionStatUpdateWithWhereUniqueWithoutChampionInput {
  data: ChampionStatUpdateWithoutChampionInput!
  where: ChampionStatWhereUniqueInput!
}

input ChampionStatUpdateWithWhereUniqueWithoutPeriodInput {
  data: ChampionStatUpdateWithoutPeriodInput!
  where: ChampionStatWhereUniqueInput!
}

input ChampionStatUpdateWithoutChampionInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  period: PeriodUpdateOneRequiredWithoutChampionStatsNestedInput
  support: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userStats: StatUpdateManyWithoutChampionNestedInput
  winrate: FloatFieldUpdateOperationsInput
}

input ChampionStatUpdateWithoutPeriodInput {
  champion: ChampionUpdateOneRequiredWithoutStatsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  support: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userStats: StatUpdateManyWithoutChampionNestedInput
  winrate: FloatFieldUpdateOperationsInput
}

input ChampionStatUpdateWithoutUserStatsInput {
  champion: ChampionUpdateOneRequiredWithoutStatsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  period: PeriodUpdateOneRequiredWithoutChampionStatsNestedInput
  support: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  winrate: FloatFieldUpdateOperationsInput
}

input ChampionStatUpsertWithWhereUniqueWithoutChampionInput {
  create: ChampionStatCreateWithoutChampionInput!
  update: ChampionStatUpdateWithoutChampionInput!
  where: ChampionStatWhereUniqueInput!
}

input ChampionStatUpsertWithWhereUniqueWithoutPeriodInput {
  create: ChampionStatCreateWithoutPeriodInput!
  update: ChampionStatUpdateWithoutPeriodInput!
  where: ChampionStatWhereUniqueInput!
}

input ChampionStatUpsertWithoutUserStatsInput {
  create: ChampionStatCreateWithoutUserStatsInput!
  update: ChampionStatUpdateWithoutUserStatsInput!
}

input ChampionStatWhereInput {
  AND: [ChampionStatWhereInput!]
  NOT: [ChampionStatWhereInput!]
  OR: [ChampionStatWhereInput!]
  champion: ChampionRelationFilter
  championId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  period: PeriodRelationFilter
  periodId: IntFilter
  support: BoolFilter
  updatedAt: DateTimeFilter
  userStats: StatListRelationFilter
  winrate: FloatFilter
}

input ChampionStatWhereUniqueInput {
  id: Int
}

type ChampionSumAggregate {
  id: Int
}

input ChampionSumOrderByAggregateInput {
  id: SortOrder
}

input ChampionUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  players: PlayerStatUpdateManyWithoutChampionNestedInput
  stats: ChampionStatUpdateManyWithoutChampionNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChampionUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChampionUpdateOneRequiredWithoutPlayersNestedInput {
  connect: ChampionWhereUniqueInput
  connectOrCreate: ChampionCreateOrConnectWithoutPlayersInput
  create: ChampionCreateWithoutPlayersInput
  update: ChampionUpdateWithoutPlayersInput
  upsert: ChampionUpsertWithoutPlayersInput
}

input ChampionUpdateOneRequiredWithoutStatsNestedInput {
  connect: ChampionWhereUniqueInput
  connectOrCreate: ChampionCreateOrConnectWithoutStatsInput
  create: ChampionCreateWithoutStatsInput
  update: ChampionUpdateWithoutStatsInput
  upsert: ChampionUpsertWithoutStatsInput
}

input ChampionUpdateWithoutPlayersInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  stats: ChampionStatUpdateManyWithoutChampionNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChampionUpdateWithoutStatsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  players: PlayerStatUpdateManyWithoutChampionNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChampionUpsertWithoutPlayersInput {
  create: ChampionCreateWithoutPlayersInput!
  update: ChampionUpdateWithoutPlayersInput!
}

input ChampionUpsertWithoutStatsInput {
  create: ChampionCreateWithoutStatsInput!
  update: ChampionUpdateWithoutStatsInput!
}

input ChampionWhereInput {
  AND: [ChampionWhereInput!]
  NOT: [ChampionWhereInput!]
  OR: [ChampionWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  players: PlayerStatListRelationFilter
  stats: ChampionStatListRelationFilter
  updatedAt: DateTimeFilter
}

input ChampionWhereUniqueInput {
  id: Int
  name: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input FloatNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedFloatNullableFilter
  _min: NestedFloatNullableFilter
  _sum: NestedFloatNullableFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableWithAggregatesFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

type Game {
  _count: GameCount
  createdAt: DateTime!
  duration: Float
  id: Int!
  matchId: String!
  matchLoaded: Boolean!
  period: Period
  periodId: Int
  players(cursor: PlayerStatWhereUniqueInput, distinct: [PlayerStatScalarFieldEnum!], orderBy: [PlayerStatOrderByWithRelationInput!], skip: Int, take: Int, where: PlayerStatWhereInput): [PlayerStat!]!
  stats(cursor: StatWhereUniqueInput, distinct: [StatScalarFieldEnum!], orderBy: [StatOrderByWithRelationInput!], skip: Int, take: Int, where: StatWhereInput): [Stat!]!
  updatedAt: DateTime!
}

type GameAvgAggregate {
  duration: Float
  id: Float
  periodId: Float
}

input GameAvgOrderByAggregateInput {
  duration: SortOrder
  id: SortOrder
  periodId: SortOrder
}

type GameCount {
  players: Int!
  stats: Int!
}

type GameCountAggregate {
  _all: Int!
  createdAt: Int!
  duration: Int!
  id: Int!
  matchId: Int!
  matchLoaded: Int!
  periodId: Int!
  updatedAt: Int!
}

input GameCountOrderByAggregateInput {
  createdAt: SortOrder
  duration: SortOrder
  id: SortOrder
  matchId: SortOrder
  matchLoaded: SortOrder
  periodId: SortOrder
  updatedAt: SortOrder
}

input GameCreateInput {
  createdAt: DateTime
  duration: Float
  matchId: String!
  matchLoaded: Boolean
  period: PeriodCreateNestedOneWithoutGamesInput
  players: PlayerStatCreateNestedManyWithoutGameInput
  stats: StatCreateNestedManyWithoutGameInput
  updatedAt: DateTime
}

input GameCreateManyInput {
  createdAt: DateTime
  duration: Float
  id: Int
  matchId: String!
  matchLoaded: Boolean
  periodId: Int
  updatedAt: DateTime
}

input GameCreateManyPeriodInput {
  createdAt: DateTime
  duration: Float
  id: Int
  matchId: String!
  matchLoaded: Boolean
  updatedAt: DateTime
}

input GameCreateManyPeriodInputEnvelope {
  data: [GameCreateManyPeriodInput!]!
  skipDuplicates: Boolean
}

input GameCreateNestedManyWithoutPeriodInput {
  connect: [GameWhereUniqueInput!]
  connectOrCreate: [GameCreateOrConnectWithoutPeriodInput!]
  create: [GameCreateWithoutPeriodInput!]
  createMany: GameCreateManyPeriodInputEnvelope
}

input GameCreateNestedOneWithoutPlayersInput {
  connect: GameWhereUniqueInput
  connectOrCreate: GameCreateOrConnectWithoutPlayersInput
  create: GameCreateWithoutPlayersInput
}

input GameCreateNestedOneWithoutStatsInput {
  connect: GameWhereUniqueInput
  connectOrCreate: GameCreateOrConnectWithoutStatsInput
  create: GameCreateWithoutStatsInput
}

input GameCreateOrConnectWithoutPeriodInput {
  create: GameCreateWithoutPeriodInput!
  where: GameWhereUniqueInput!
}

input GameCreateOrConnectWithoutPlayersInput {
  create: GameCreateWithoutPlayersInput!
  where: GameWhereUniqueInput!
}

input GameCreateOrConnectWithoutStatsInput {
  create: GameCreateWithoutStatsInput!
  where: GameWhereUniqueInput!
}

input GameCreateWithoutPeriodInput {
  createdAt: DateTime
  duration: Float
  matchId: String!
  matchLoaded: Boolean
  players: PlayerStatCreateNestedManyWithoutGameInput
  stats: StatCreateNestedManyWithoutGameInput
  updatedAt: DateTime
}

input GameCreateWithoutPlayersInput {
  createdAt: DateTime
  duration: Float
  matchId: String!
  matchLoaded: Boolean
  period: PeriodCreateNestedOneWithoutGamesInput
  stats: StatCreateNestedManyWithoutGameInput
  updatedAt: DateTime
}

input GameCreateWithoutStatsInput {
  createdAt: DateTime
  duration: Float
  matchId: String!
  matchLoaded: Boolean
  period: PeriodCreateNestedOneWithoutGamesInput
  players: PlayerStatCreateNestedManyWithoutGameInput
  updatedAt: DateTime
}

type GameGroupBy {
  _avg: GameAvgAggregate
  _count: GameCountAggregate
  _max: GameMaxAggregate
  _min: GameMinAggregate
  _sum: GameSumAggregate
  createdAt: DateTime!
  duration: Float
  id: Int!
  matchId: String!
  matchLoaded: Boolean!
  periodId: Int
  updatedAt: DateTime!
}

input GameListRelationFilter {
  every: GameWhereInput
  none: GameWhereInput
  some: GameWhereInput
}

type GameMaxAggregate {
  createdAt: DateTime
  duration: Float
  id: Int
  matchId: String
  matchLoaded: Boolean
  periodId: Int
  updatedAt: DateTime
}

input GameMaxOrderByAggregateInput {
  createdAt: SortOrder
  duration: SortOrder
  id: SortOrder
  matchId: SortOrder
  matchLoaded: SortOrder
  periodId: SortOrder
  updatedAt: SortOrder
}

type GameMinAggregate {
  createdAt: DateTime
  duration: Float
  id: Int
  matchId: String
  matchLoaded: Boolean
  periodId: Int
  updatedAt: DateTime
}

input GameMinOrderByAggregateInput {
  createdAt: SortOrder
  duration: SortOrder
  id: SortOrder
  matchId: SortOrder
  matchLoaded: SortOrder
  periodId: SortOrder
  updatedAt: SortOrder
}

input GameOrderByRelationAggregateInput {
  _count: SortOrder
}

input GameOrderByWithAggregationInput {
  _avg: GameAvgOrderByAggregateInput
  _count: GameCountOrderByAggregateInput
  _max: GameMaxOrderByAggregateInput
  _min: GameMinOrderByAggregateInput
  _sum: GameSumOrderByAggregateInput
  createdAt: SortOrder
  duration: SortOrder
  id: SortOrder
  matchId: SortOrder
  matchLoaded: SortOrder
  periodId: SortOrder
  updatedAt: SortOrder
}

input GameOrderByWithRelationInput {
  createdAt: SortOrder
  duration: SortOrder
  id: SortOrder
  matchId: SortOrder
  matchLoaded: SortOrder
  period: PeriodOrderByWithRelationInput
  periodId: SortOrder
  players: PlayerStatOrderByRelationAggregateInput
  stats: StatOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input GameRelationFilter {
  is: GameWhereInput
  isNot: GameWhereInput
}

enum GameScalarFieldEnum {
  createdAt
  duration
  id
  matchId
  matchLoaded
  periodId
  updatedAt
}

input GameScalarWhereInput {
  AND: [GameScalarWhereInput!]
  NOT: [GameScalarWhereInput!]
  OR: [GameScalarWhereInput!]
  createdAt: DateTimeFilter
  duration: FloatNullableFilter
  id: IntFilter
  matchId: StringFilter
  matchLoaded: BoolFilter
  periodId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input GameScalarWhereWithAggregatesInput {
  AND: [GameScalarWhereWithAggregatesInput!]
  NOT: [GameScalarWhereWithAggregatesInput!]
  OR: [GameScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  duration: FloatNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  matchId: StringWithAggregatesFilter
  matchLoaded: BoolWithAggregatesFilter
  periodId: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type GameSumAggregate {
  duration: Float
  id: Int
  periodId: Int
}

input GameSumOrderByAggregateInput {
  duration: SortOrder
  id: SortOrder
  periodId: SortOrder
}

input GameUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: NullableFloatFieldUpdateOperationsInput
  matchId: StringFieldUpdateOperationsInput
  matchLoaded: BoolFieldUpdateOperationsInput
  period: PeriodUpdateOneWithoutGamesNestedInput
  players: PlayerStatUpdateManyWithoutGameNestedInput
  stats: StatUpdateManyWithoutGameNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GameUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: NullableFloatFieldUpdateOperationsInput
  matchId: StringFieldUpdateOperationsInput
  matchLoaded: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GameUpdateManyWithWhereWithoutPeriodInput {
  data: GameUpdateManyMutationInput!
  where: GameScalarWhereInput!
}

input GameUpdateManyWithoutPeriodNestedInput {
  connect: [GameWhereUniqueInput!]
  connectOrCreate: [GameCreateOrConnectWithoutPeriodInput!]
  create: [GameCreateWithoutPeriodInput!]
  createMany: GameCreateManyPeriodInputEnvelope
  delete: [GameWhereUniqueInput!]
  deleteMany: [GameScalarWhereInput!]
  disconnect: [GameWhereUniqueInput!]
  set: [GameWhereUniqueInput!]
  update: [GameUpdateWithWhereUniqueWithoutPeriodInput!]
  updateMany: [GameUpdateManyWithWhereWithoutPeriodInput!]
  upsert: [GameUpsertWithWhereUniqueWithoutPeriodInput!]
}

input GameUpdateOneRequiredWithoutPlayersNestedInput {
  connect: GameWhereUniqueInput
  connectOrCreate: GameCreateOrConnectWithoutPlayersInput
  create: GameCreateWithoutPlayersInput
  update: GameUpdateWithoutPlayersInput
  upsert: GameUpsertWithoutPlayersInput
}

input GameUpdateOneWithoutStatsNestedInput {
  connect: GameWhereUniqueInput
  connectOrCreate: GameCreateOrConnectWithoutStatsInput
  create: GameCreateWithoutStatsInput
  delete: Boolean
  disconnect: Boolean
  update: GameUpdateWithoutStatsInput
  upsert: GameUpsertWithoutStatsInput
}

input GameUpdateWithWhereUniqueWithoutPeriodInput {
  data: GameUpdateWithoutPeriodInput!
  where: GameWhereUniqueInput!
}

input GameUpdateWithoutPeriodInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: NullableFloatFieldUpdateOperationsInput
  matchId: StringFieldUpdateOperationsInput
  matchLoaded: BoolFieldUpdateOperationsInput
  players: PlayerStatUpdateManyWithoutGameNestedInput
  stats: StatUpdateManyWithoutGameNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GameUpdateWithoutPlayersInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: NullableFloatFieldUpdateOperationsInput
  matchId: StringFieldUpdateOperationsInput
  matchLoaded: BoolFieldUpdateOperationsInput
  period: PeriodUpdateOneWithoutGamesNestedInput
  stats: StatUpdateManyWithoutGameNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GameUpdateWithoutStatsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: NullableFloatFieldUpdateOperationsInput
  matchId: StringFieldUpdateOperationsInput
  matchLoaded: BoolFieldUpdateOperationsInput
  period: PeriodUpdateOneWithoutGamesNestedInput
  players: PlayerStatUpdateManyWithoutGameNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GameUpsertWithWhereUniqueWithoutPeriodInput {
  create: GameCreateWithoutPeriodInput!
  update: GameUpdateWithoutPeriodInput!
  where: GameWhereUniqueInput!
}

input GameUpsertWithoutPlayersInput {
  create: GameCreateWithoutPlayersInput!
  update: GameUpdateWithoutPlayersInput!
}

input GameUpsertWithoutStatsInput {
  create: GameCreateWithoutStatsInput!
  update: GameUpdateWithoutStatsInput!
}

input GameWhereInput {
  AND: [GameWhereInput!]
  NOT: [GameWhereInput!]
  OR: [GameWhereInput!]
  createdAt: DateTimeFilter
  duration: FloatNullableFilter
  id: IntFilter
  matchId: StringFilter
  matchLoaded: BoolFilter
  period: PeriodRelationFilter
  periodId: IntNullableFilter
  players: PlayerStatListRelationFilter
  stats: StatListRelationFilter
  updatedAt: DateTimeFilter
}

input GameWhereUniqueInput {
  id: Int
  matchId: String
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Item {
  _count: ItemCount
  createdAt: DateTime!
  id: Int!
  name: String!
  players(cursor: PlayerStatWhereUniqueInput, distinct: [PlayerStatScalarFieldEnum!], orderBy: [PlayerStatOrderByWithRelationInput!], skip: Int, take: Int, where: PlayerStatWhereInput): [PlayerStat!]!
  updatedAt: DateTime!
}

type ItemAvgAggregate {
  id: Float
}

input ItemAvgOrderByAggregateInput {
  id: SortOrder
}

type ItemCount {
  players: Int!
}

type ItemCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input ItemCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ItemCreateInput {
  createdAt: DateTime
  name: String!
  players: PlayerStatCreateNestedManyWithoutItemsInput
  updatedAt: DateTime
}

input ItemCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input ItemCreateNestedManyWithoutPlayersInput {
  connect: [ItemWhereUniqueInput!]
  connectOrCreate: [ItemCreateOrConnectWithoutPlayersInput!]
  create: [ItemCreateWithoutPlayersInput!]
}

input ItemCreateOrConnectWithoutPlayersInput {
  create: ItemCreateWithoutPlayersInput!
  where: ItemWhereUniqueInput!
}

input ItemCreateWithoutPlayersInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

type ItemGroupBy {
  _avg: ItemAvgAggregate
  _count: ItemCountAggregate
  _max: ItemMaxAggregate
  _min: ItemMinAggregate
  _sum: ItemSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

input ItemListRelationFilter {
  every: ItemWhereInput
  none: ItemWhereInput
  some: ItemWhereInput
}

type ItemMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input ItemMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type ItemMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input ItemMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ItemOrderByRelationAggregateInput {
  _count: SortOrder
}

input ItemOrderByWithAggregationInput {
  _avg: ItemAvgOrderByAggregateInput
  _count: ItemCountOrderByAggregateInput
  _max: ItemMaxOrderByAggregateInput
  _min: ItemMinOrderByAggregateInput
  _sum: ItemSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ItemOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  players: PlayerStatOrderByRelationAggregateInput
  updatedAt: SortOrder
}

enum ItemScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input ItemScalarWhereInput {
  AND: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input ItemScalarWhereWithAggregatesInput {
  AND: [ItemScalarWhereWithAggregatesInput!]
  NOT: [ItemScalarWhereWithAggregatesInput!]
  OR: [ItemScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ItemSumAggregate {
  id: Int
}

input ItemSumOrderByAggregateInput {
  id: SortOrder
}

input ItemUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  players: PlayerStatUpdateManyWithoutItemsNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ItemUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ItemUpdateManyWithWhereWithoutPlayersInput {
  data: ItemUpdateManyMutationInput!
  where: ItemScalarWhereInput!
}

input ItemUpdateManyWithoutPlayersNestedInput {
  connect: [ItemWhereUniqueInput!]
  connectOrCreate: [ItemCreateOrConnectWithoutPlayersInput!]
  create: [ItemCreateWithoutPlayersInput!]
  delete: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  disconnect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutPlayersInput!]
  updateMany: [ItemUpdateManyWithWhereWithoutPlayersInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutPlayersInput!]
}

input ItemUpdateWithWhereUniqueWithoutPlayersInput {
  data: ItemUpdateWithoutPlayersInput!
  where: ItemWhereUniqueInput!
}

input ItemUpdateWithoutPlayersInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ItemUpsertWithWhereUniqueWithoutPlayersInput {
  create: ItemCreateWithoutPlayersInput!
  update: ItemUpdateWithoutPlayersInput!
  where: ItemWhereUniqueInput!
}

input ItemWhereInput {
  AND: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  players: PlayerStatListRelationFilter
  updatedAt: DateTimeFilter
}

input ItemWhereUniqueInput {
  id: Int
  name: String
}

type Mutation {
  createManyChampion(data: [ChampionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyChampionStat(data: [ChampionStatCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyGame(data: [GameCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyItem(data: [ItemCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPeriod(data: [PeriodCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPlayerStat(data: [PlayerStatCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyStat(data: [StatCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySumSpells(data: [SumSpellsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneChampion(data: ChampionCreateInput!): Champion!
  createOneChampionStat(data: ChampionStatCreateInput!): ChampionStat!
  createOneGame(data: GameCreateInput!): Game!
  createOneItem(data: ItemCreateInput!): Item!
  createOnePeriod(data: PeriodCreateInput!): Period!
  createOnePlayerStat(data: PlayerStatCreateInput!): PlayerStat!
  createOneStat(data: StatCreateInput!): Stat!
  createOneSumSpells(data: SumSpellsCreateInput!): SumSpells!
  createOneUser(data: UserCreateInput!): User!
  createUser(data: UserCreateInput!): User!
  deleteManyChampion(where: ChampionWhereInput): AffectedRowsOutput!
  deleteManyChampionStat(where: ChampionStatWhereInput): AffectedRowsOutput!
  deleteManyGame(where: GameWhereInput): AffectedRowsOutput!
  deleteManyItem(where: ItemWhereInput): AffectedRowsOutput!
  deleteManyPeriod(where: PeriodWhereInput): AffectedRowsOutput!
  deleteManyPlayerStat(where: PlayerStatWhereInput): AffectedRowsOutput!
  deleteManyStat(where: StatWhereInput): AffectedRowsOutput!
  deleteManySumSpells(where: SumSpellsWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneChampion(where: ChampionWhereUniqueInput!): Champion
  deleteOneChampionStat(where: ChampionStatWhereUniqueInput!): ChampionStat
  deleteOneGame(where: GameWhereUniqueInput!): Game
  deleteOneItem(where: ItemWhereUniqueInput!): Item
  deleteOnePeriod(where: PeriodWhereUniqueInput!): Period
  deleteOnePlayerStat(where: PlayerStatWhereUniqueInput!): PlayerStat
  deleteOneStat(where: StatWhereUniqueInput!): Stat
  deleteOneSumSpells(where: SumSpellsWhereUniqueInput!): SumSpells
  deleteOneUser(where: UserWhereUniqueInput!): User
  syncUsersMatches(args: UserWhereUniqueInput): [User!]!
  updateManyChampion(data: ChampionUpdateManyMutationInput!, where: ChampionWhereInput): AffectedRowsOutput!
  updateManyChampionStat(data: ChampionStatUpdateManyMutationInput!, where: ChampionStatWhereInput): AffectedRowsOutput!
  updateManyGame(data: GameUpdateManyMutationInput!, where: GameWhereInput): AffectedRowsOutput!
  updateManyItem(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): AffectedRowsOutput!
  updateManyPeriod(data: PeriodUpdateManyMutationInput!, where: PeriodWhereInput): AffectedRowsOutput!
  updateManyPlayerStat(data: PlayerStatUpdateManyMutationInput!, where: PlayerStatWhereInput): AffectedRowsOutput!
  updateManyStat(data: StatUpdateManyMutationInput!, where: StatWhereInput): AffectedRowsOutput!
  updateManySumSpells(data: SumSpellsUpdateManyMutationInput!, where: SumSpellsWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneChampion(data: ChampionUpdateInput!, where: ChampionWhereUniqueInput!): Champion
  updateOneChampionStat(data: ChampionStatUpdateInput!, where: ChampionStatWhereUniqueInput!): ChampionStat
  updateOneGame(data: GameUpdateInput!, where: GameWhereUniqueInput!): Game
  updateOneItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateOnePeriod(data: PeriodUpdateInput!, where: PeriodWhereUniqueInput!): Period
  updateOnePlayerStat(data: PlayerStatUpdateInput!, where: PlayerStatWhereUniqueInput!): PlayerStat
  updateOneStat(data: StatUpdateInput!, where: StatWhereUniqueInput!): Stat
  updateOneSumSpells(data: SumSpellsUpdateInput!, where: SumSpellsWhereUniqueInput!): SumSpells
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneChampion(create: ChampionCreateInput!, update: ChampionUpdateInput!, where: ChampionWhereUniqueInput!): Champion!
  upsertOneChampionStat(create: ChampionStatCreateInput!, update: ChampionStatUpdateInput!, where: ChampionStatWhereUniqueInput!): ChampionStat!
  upsertOneGame(create: GameCreateInput!, update: GameUpdateInput!, where: GameWhereUniqueInput!): Game!
  upsertOneItem(create: ItemCreateInput!, update: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item!
  upsertOnePeriod(create: PeriodCreateInput!, update: PeriodUpdateInput!, where: PeriodWhereUniqueInput!): Period!
  upsertOnePlayerStat(create: PlayerStatCreateInput!, update: PlayerStatUpdateInput!, where: PlayerStatWhereUniqueInput!): PlayerStat!
  upsertOneStat(create: StatCreateInput!, update: StatUpdateInput!, where: StatWhereUniqueInput!): Stat!
  upsertOneSumSpells(create: SumSpellsCreateInput!, update: SumSpellsUpdateInput!, where: SumSpellsWhereUniqueInput!): SumSpells!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedFloatNullableFilter
  _min: NestedFloatNullableFilter
  _sum: NestedFloatNullableFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableWithAggregatesFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableFloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Period {
  _count: PeriodCount
  championStats(cursor: ChampionStatWhereUniqueInput, distinct: [ChampionStatScalarFieldEnum!], orderBy: [ChampionStatOrderByWithRelationInput!], skip: Int, take: Int, where: ChampionStatWhereInput): [ChampionStat!]!
  createdAt: DateTime!
  date: DateTime!
  games(cursor: GameWhereUniqueInput, distinct: [GameScalarFieldEnum!], orderBy: [GameOrderByWithRelationInput!], skip: Int, take: Int, where: GameWhereInput): [Game!]!
  id: Int!
  stats(cursor: StatWhereUniqueInput, distinct: [StatScalarFieldEnum!], orderBy: [StatOrderByWithRelationInput!], skip: Int, take: Int, where: StatWhereInput): [Stat!]!
  updatedAt: DateTime!
}

type PeriodAvgAggregate {
  id: Float
}

input PeriodAvgOrderByAggregateInput {
  id: SortOrder
}

type PeriodCount {
  championStats: Int!
  games: Int!
  stats: Int!
}

type PeriodCountAggregate {
  _all: Int!
  createdAt: Int!
  date: Int!
  id: Int!
  updatedAt: Int!
}

input PeriodCountOrderByAggregateInput {
  createdAt: SortOrder
  date: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input PeriodCreateInput {
  championStats: ChampionStatCreateNestedManyWithoutPeriodInput
  createdAt: DateTime
  date: DateTime!
  games: GameCreateNestedManyWithoutPeriodInput
  stats: StatCreateNestedManyWithoutPeriodInput
  updatedAt: DateTime
}

input PeriodCreateManyInput {
  createdAt: DateTime
  date: DateTime!
  id: Int
  updatedAt: DateTime
}

input PeriodCreateNestedOneWithoutChampionStatsInput {
  connect: PeriodWhereUniqueInput
  connectOrCreate: PeriodCreateOrConnectWithoutChampionStatsInput
  create: PeriodCreateWithoutChampionStatsInput
}

input PeriodCreateNestedOneWithoutGamesInput {
  connect: PeriodWhereUniqueInput
  connectOrCreate: PeriodCreateOrConnectWithoutGamesInput
  create: PeriodCreateWithoutGamesInput
}

input PeriodCreateNestedOneWithoutStatsInput {
  connect: PeriodWhereUniqueInput
  connectOrCreate: PeriodCreateOrConnectWithoutStatsInput
  create: PeriodCreateWithoutStatsInput
}

input PeriodCreateOrConnectWithoutChampionStatsInput {
  create: PeriodCreateWithoutChampionStatsInput!
  where: PeriodWhereUniqueInput!
}

input PeriodCreateOrConnectWithoutGamesInput {
  create: PeriodCreateWithoutGamesInput!
  where: PeriodWhereUniqueInput!
}

input PeriodCreateOrConnectWithoutStatsInput {
  create: PeriodCreateWithoutStatsInput!
  where: PeriodWhereUniqueInput!
}

input PeriodCreateWithoutChampionStatsInput {
  createdAt: DateTime
  date: DateTime!
  games: GameCreateNestedManyWithoutPeriodInput
  stats: StatCreateNestedManyWithoutPeriodInput
  updatedAt: DateTime
}

input PeriodCreateWithoutGamesInput {
  championStats: ChampionStatCreateNestedManyWithoutPeriodInput
  createdAt: DateTime
  date: DateTime!
  stats: StatCreateNestedManyWithoutPeriodInput
  updatedAt: DateTime
}

input PeriodCreateWithoutStatsInput {
  championStats: ChampionStatCreateNestedManyWithoutPeriodInput
  createdAt: DateTime
  date: DateTime!
  games: GameCreateNestedManyWithoutPeriodInput
  updatedAt: DateTime
}

type PeriodGroupBy {
  _avg: PeriodAvgAggregate
  _count: PeriodCountAggregate
  _max: PeriodMaxAggregate
  _min: PeriodMinAggregate
  _sum: PeriodSumAggregate
  createdAt: DateTime!
  date: DateTime!
  id: Int!
  updatedAt: DateTime!
}

type PeriodMaxAggregate {
  createdAt: DateTime
  date: DateTime
  id: Int
  updatedAt: DateTime
}

input PeriodMaxOrderByAggregateInput {
  createdAt: SortOrder
  date: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

type PeriodMinAggregate {
  createdAt: DateTime
  date: DateTime
  id: Int
  updatedAt: DateTime
}

input PeriodMinOrderByAggregateInput {
  createdAt: SortOrder
  date: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input PeriodOrderByWithAggregationInput {
  _avg: PeriodAvgOrderByAggregateInput
  _count: PeriodCountOrderByAggregateInput
  _max: PeriodMaxOrderByAggregateInput
  _min: PeriodMinOrderByAggregateInput
  _sum: PeriodSumOrderByAggregateInput
  createdAt: SortOrder
  date: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input PeriodOrderByWithRelationInput {
  championStats: ChampionStatOrderByRelationAggregateInput
  createdAt: SortOrder
  date: SortOrder
  games: GameOrderByRelationAggregateInput
  id: SortOrder
  stats: StatOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input PeriodRelationFilter {
  is: PeriodWhereInput
  isNot: PeriodWhereInput
}

enum PeriodScalarFieldEnum {
  createdAt
  date
  id
  updatedAt
}

input PeriodScalarWhereWithAggregatesInput {
  AND: [PeriodScalarWhereWithAggregatesInput!]
  NOT: [PeriodScalarWhereWithAggregatesInput!]
  OR: [PeriodScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  date: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type PeriodSumAggregate {
  id: Int
}

input PeriodSumOrderByAggregateInput {
  id: SortOrder
}

input PeriodUpdateInput {
  championStats: ChampionStatUpdateManyWithoutPeriodNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  games: GameUpdateManyWithoutPeriodNestedInput
  stats: StatUpdateManyWithoutPeriodNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PeriodUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PeriodUpdateOneRequiredWithoutChampionStatsNestedInput {
  connect: PeriodWhereUniqueInput
  connectOrCreate: PeriodCreateOrConnectWithoutChampionStatsInput
  create: PeriodCreateWithoutChampionStatsInput
  update: PeriodUpdateWithoutChampionStatsInput
  upsert: PeriodUpsertWithoutChampionStatsInput
}

input PeriodUpdateOneWithoutGamesNestedInput {
  connect: PeriodWhereUniqueInput
  connectOrCreate: PeriodCreateOrConnectWithoutGamesInput
  create: PeriodCreateWithoutGamesInput
  delete: Boolean
  disconnect: Boolean
  update: PeriodUpdateWithoutGamesInput
  upsert: PeriodUpsertWithoutGamesInput
}

input PeriodUpdateOneWithoutStatsNestedInput {
  connect: PeriodWhereUniqueInput
  connectOrCreate: PeriodCreateOrConnectWithoutStatsInput
  create: PeriodCreateWithoutStatsInput
  delete: Boolean
  disconnect: Boolean
  update: PeriodUpdateWithoutStatsInput
  upsert: PeriodUpsertWithoutStatsInput
}

input PeriodUpdateWithoutChampionStatsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  games: GameUpdateManyWithoutPeriodNestedInput
  stats: StatUpdateManyWithoutPeriodNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PeriodUpdateWithoutGamesInput {
  championStats: ChampionStatUpdateManyWithoutPeriodNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  stats: StatUpdateManyWithoutPeriodNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PeriodUpdateWithoutStatsInput {
  championStats: ChampionStatUpdateManyWithoutPeriodNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  games: GameUpdateManyWithoutPeriodNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PeriodUpsertWithoutChampionStatsInput {
  create: PeriodCreateWithoutChampionStatsInput!
  update: PeriodUpdateWithoutChampionStatsInput!
}

input PeriodUpsertWithoutGamesInput {
  create: PeriodCreateWithoutGamesInput!
  update: PeriodUpdateWithoutGamesInput!
}

input PeriodUpsertWithoutStatsInput {
  create: PeriodCreateWithoutStatsInput!
  update: PeriodUpdateWithoutStatsInput!
}

input PeriodWhereInput {
  AND: [PeriodWhereInput!]
  NOT: [PeriodWhereInput!]
  OR: [PeriodWhereInput!]
  championStats: ChampionStatListRelationFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  games: GameListRelationFilter
  id: IntFilter
  stats: StatListRelationFilter
  updatedAt: DateTimeFilter
}

input PeriodWhereUniqueInput {
  id: Int
}

type PlayerStat {
  _count: PlayerStatCount
  allyTeam: Boolean!
  assists: Int!
  champion: Champion!
  championId: Int!
  createdAt: DateTime!
  damage: Float!
  deaths: Int!
  game: Game!
  gameId: Int!
  id: Int!
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  kills: Int!
  reduction: Float!
  sumSpells(cursor: SumSpellsWhereUniqueInput, distinct: [SumSpellsScalarFieldEnum!], orderBy: [SumSpellsOrderByWithRelationInput!], skip: Int, take: Int, where: SumSpellsWhereInput): [SumSpells!]!
  updatedAt: DateTime!
  user: User
  userId: Int
}

type PlayerStatAvgAggregate {
  assists: Float
  championId: Float
  damage: Float
  deaths: Float
  gameId: Float
  id: Float
  kills: Float
  reduction: Float
  userId: Float
}

input PlayerStatAvgOrderByAggregateInput {
  assists: SortOrder
  championId: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kills: SortOrder
  reduction: SortOrder
  userId: SortOrder
}

type PlayerStatCount {
  items: Int!
  sumSpells: Int!
}

type PlayerStatCountAggregate {
  _all: Int!
  allyTeam: Int!
  assists: Int!
  championId: Int!
  createdAt: Int!
  damage: Int!
  deaths: Int!
  gameId: Int!
  id: Int!
  kills: Int!
  reduction: Int!
  updatedAt: Int!
  userId: Int!
}

input PlayerStatCountOrderByAggregateInput {
  allyTeam: SortOrder
  assists: SortOrder
  championId: SortOrder
  createdAt: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kills: SortOrder
  reduction: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PlayerStatCreateInput {
  allyTeam: Boolean!
  assists: Int!
  champion: ChampionCreateNestedOneWithoutPlayersInput!
  createdAt: DateTime
  damage: Float!
  deaths: Int!
  game: GameCreateNestedOneWithoutPlayersInput!
  items: ItemCreateNestedManyWithoutPlayersInput
  kills: Int!
  reduction: Float!
  sumSpells: SumSpellsCreateNestedManyWithoutPlayersInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutGameStatsInput
}

input PlayerStatCreateManyChampionInput {
  allyTeam: Boolean!
  assists: Int!
  createdAt: DateTime
  damage: Float!
  deaths: Int!
  gameId: Int!
  id: Int
  kills: Int!
  reduction: Float!
  updatedAt: DateTime
  userId: Int
}

input PlayerStatCreateManyChampionInputEnvelope {
  data: [PlayerStatCreateManyChampionInput!]!
  skipDuplicates: Boolean
}

input PlayerStatCreateManyGameInput {
  allyTeam: Boolean!
  assists: Int!
  championId: Int!
  createdAt: DateTime
  damage: Float!
  deaths: Int!
  id: Int
  kills: Int!
  reduction: Float!
  updatedAt: DateTime
  userId: Int
}

input PlayerStatCreateManyGameInputEnvelope {
  data: [PlayerStatCreateManyGameInput!]!
  skipDuplicates: Boolean
}

input PlayerStatCreateManyInput {
  allyTeam: Boolean!
  assists: Int!
  championId: Int!
  createdAt: DateTime
  damage: Float!
  deaths: Int!
  gameId: Int!
  id: Int
  kills: Int!
  reduction: Float!
  updatedAt: DateTime
  userId: Int
}

input PlayerStatCreateManyUserInput {
  allyTeam: Boolean!
  assists: Int!
  championId: Int!
  createdAt: DateTime
  damage: Float!
  deaths: Int!
  gameId: Int!
  id: Int
  kills: Int!
  reduction: Float!
  updatedAt: DateTime
}

input PlayerStatCreateManyUserInputEnvelope {
  data: [PlayerStatCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input PlayerStatCreateNestedManyWithoutChampionInput {
  connect: [PlayerStatWhereUniqueInput!]
  connectOrCreate: [PlayerStatCreateOrConnectWithoutChampionInput!]
  create: [PlayerStatCreateWithoutChampionInput!]
  createMany: PlayerStatCreateManyChampionInputEnvelope
}

input PlayerStatCreateNestedManyWithoutGameInput {
  connect: [PlayerStatWhereUniqueInput!]
  connectOrCreate: [PlayerStatCreateOrConnectWithoutGameInput!]
  create: [PlayerStatCreateWithoutGameInput!]
  createMany: PlayerStatCreateManyGameInputEnvelope
}

input PlayerStatCreateNestedManyWithoutItemsInput {
  connect: [PlayerStatWhereUniqueInput!]
  connectOrCreate: [PlayerStatCreateOrConnectWithoutItemsInput!]
  create: [PlayerStatCreateWithoutItemsInput!]
}

input PlayerStatCreateNestedManyWithoutSumSpellsInput {
  connect: [PlayerStatWhereUniqueInput!]
  connectOrCreate: [PlayerStatCreateOrConnectWithoutSumSpellsInput!]
  create: [PlayerStatCreateWithoutSumSpellsInput!]
}

input PlayerStatCreateNestedManyWithoutUserInput {
  connect: [PlayerStatWhereUniqueInput!]
  connectOrCreate: [PlayerStatCreateOrConnectWithoutUserInput!]
  create: [PlayerStatCreateWithoutUserInput!]
  createMany: PlayerStatCreateManyUserInputEnvelope
}

input PlayerStatCreateOrConnectWithoutChampionInput {
  create: PlayerStatCreateWithoutChampionInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatCreateOrConnectWithoutGameInput {
  create: PlayerStatCreateWithoutGameInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatCreateOrConnectWithoutItemsInput {
  create: PlayerStatCreateWithoutItemsInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatCreateOrConnectWithoutSumSpellsInput {
  create: PlayerStatCreateWithoutSumSpellsInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatCreateOrConnectWithoutUserInput {
  create: PlayerStatCreateWithoutUserInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatCreateWithoutChampionInput {
  allyTeam: Boolean!
  assists: Int!
  createdAt: DateTime
  damage: Float!
  deaths: Int!
  game: GameCreateNestedOneWithoutPlayersInput!
  items: ItemCreateNestedManyWithoutPlayersInput
  kills: Int!
  reduction: Float!
  sumSpells: SumSpellsCreateNestedManyWithoutPlayersInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutGameStatsInput
}

input PlayerStatCreateWithoutGameInput {
  allyTeam: Boolean!
  assists: Int!
  champion: ChampionCreateNestedOneWithoutPlayersInput!
  createdAt: DateTime
  damage: Float!
  deaths: Int!
  items: ItemCreateNestedManyWithoutPlayersInput
  kills: Int!
  reduction: Float!
  sumSpells: SumSpellsCreateNestedManyWithoutPlayersInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutGameStatsInput
}

input PlayerStatCreateWithoutItemsInput {
  allyTeam: Boolean!
  assists: Int!
  champion: ChampionCreateNestedOneWithoutPlayersInput!
  createdAt: DateTime
  damage: Float!
  deaths: Int!
  game: GameCreateNestedOneWithoutPlayersInput!
  kills: Int!
  reduction: Float!
  sumSpells: SumSpellsCreateNestedManyWithoutPlayersInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutGameStatsInput
}

input PlayerStatCreateWithoutSumSpellsInput {
  allyTeam: Boolean!
  assists: Int!
  champion: ChampionCreateNestedOneWithoutPlayersInput!
  createdAt: DateTime
  damage: Float!
  deaths: Int!
  game: GameCreateNestedOneWithoutPlayersInput!
  items: ItemCreateNestedManyWithoutPlayersInput
  kills: Int!
  reduction: Float!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutGameStatsInput
}

input PlayerStatCreateWithoutUserInput {
  allyTeam: Boolean!
  assists: Int!
  champion: ChampionCreateNestedOneWithoutPlayersInput!
  createdAt: DateTime
  damage: Float!
  deaths: Int!
  game: GameCreateNestedOneWithoutPlayersInput!
  items: ItemCreateNestedManyWithoutPlayersInput
  kills: Int!
  reduction: Float!
  sumSpells: SumSpellsCreateNestedManyWithoutPlayersInput
  updatedAt: DateTime
}

type PlayerStatGroupBy {
  _avg: PlayerStatAvgAggregate
  _count: PlayerStatCountAggregate
  _max: PlayerStatMaxAggregate
  _min: PlayerStatMinAggregate
  _sum: PlayerStatSumAggregate
  allyTeam: Boolean!
  assists: Int!
  championId: Int!
  createdAt: DateTime!
  damage: Float!
  deaths: Int!
  gameId: Int!
  id: Int!
  kills: Int!
  reduction: Float!
  updatedAt: DateTime!
  userId: Int
}

input PlayerStatListRelationFilter {
  every: PlayerStatWhereInput
  none: PlayerStatWhereInput
  some: PlayerStatWhereInput
}

type PlayerStatMaxAggregate {
  allyTeam: Boolean
  assists: Int
  championId: Int
  createdAt: DateTime
  damage: Float
  deaths: Int
  gameId: Int
  id: Int
  kills: Int
  reduction: Float
  updatedAt: DateTime
  userId: Int
}

input PlayerStatMaxOrderByAggregateInput {
  allyTeam: SortOrder
  assists: SortOrder
  championId: SortOrder
  createdAt: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kills: SortOrder
  reduction: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type PlayerStatMinAggregate {
  allyTeam: Boolean
  assists: Int
  championId: Int
  createdAt: DateTime
  damage: Float
  deaths: Int
  gameId: Int
  id: Int
  kills: Int
  reduction: Float
  updatedAt: DateTime
  userId: Int
}

input PlayerStatMinOrderByAggregateInput {
  allyTeam: SortOrder
  assists: SortOrder
  championId: SortOrder
  createdAt: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kills: SortOrder
  reduction: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PlayerStatOrderByRelationAggregateInput {
  _count: SortOrder
}

input PlayerStatOrderByWithAggregationInput {
  _avg: PlayerStatAvgOrderByAggregateInput
  _count: PlayerStatCountOrderByAggregateInput
  _max: PlayerStatMaxOrderByAggregateInput
  _min: PlayerStatMinOrderByAggregateInput
  _sum: PlayerStatSumOrderByAggregateInput
  allyTeam: SortOrder
  assists: SortOrder
  championId: SortOrder
  createdAt: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kills: SortOrder
  reduction: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PlayerStatOrderByWithRelationInput {
  allyTeam: SortOrder
  assists: SortOrder
  champion: ChampionOrderByWithRelationInput
  championId: SortOrder
  createdAt: SortOrder
  damage: SortOrder
  deaths: SortOrder
  game: GameOrderByWithRelationInput
  gameId: SortOrder
  id: SortOrder
  items: ItemOrderByRelationAggregateInput
  kills: SortOrder
  reduction: SortOrder
  sumSpells: SumSpellsOrderByRelationAggregateInput
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum PlayerStatScalarFieldEnum {
  allyTeam
  assists
  championId
  createdAt
  damage
  deaths
  gameId
  id
  kills
  reduction
  updatedAt
  userId
}

input PlayerStatScalarWhereInput {
  AND: [PlayerStatScalarWhereInput!]
  NOT: [PlayerStatScalarWhereInput!]
  OR: [PlayerStatScalarWhereInput!]
  allyTeam: BoolFilter
  assists: IntFilter
  championId: IntFilter
  createdAt: DateTimeFilter
  damage: FloatFilter
  deaths: IntFilter
  gameId: IntFilter
  id: IntFilter
  kills: IntFilter
  reduction: FloatFilter
  updatedAt: DateTimeFilter
  userId: IntNullableFilter
}

input PlayerStatScalarWhereWithAggregatesInput {
  AND: [PlayerStatScalarWhereWithAggregatesInput!]
  NOT: [PlayerStatScalarWhereWithAggregatesInput!]
  OR: [PlayerStatScalarWhereWithAggregatesInput!]
  allyTeam: BoolWithAggregatesFilter
  assists: IntWithAggregatesFilter
  championId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  damage: FloatWithAggregatesFilter
  deaths: IntWithAggregatesFilter
  gameId: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  kills: IntWithAggregatesFilter
  reduction: FloatWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntNullableWithAggregatesFilter
}

type PlayerStatSumAggregate {
  assists: Int
  championId: Int
  damage: Float
  deaths: Int
  gameId: Int
  id: Int
  kills: Int
  reduction: Float
  userId: Int
}

input PlayerStatSumOrderByAggregateInput {
  assists: SortOrder
  championId: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kills: SortOrder
  reduction: SortOrder
  userId: SortOrder
}

input PlayerStatUpdateInput {
  allyTeam: BoolFieldUpdateOperationsInput
  assists: IntFieldUpdateOperationsInput
  champion: ChampionUpdateOneRequiredWithoutPlayersNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: FloatFieldUpdateOperationsInput
  deaths: IntFieldUpdateOperationsInput
  game: GameUpdateOneRequiredWithoutPlayersNestedInput
  items: ItemUpdateManyWithoutPlayersNestedInput
  kills: IntFieldUpdateOperationsInput
  reduction: FloatFieldUpdateOperationsInput
  sumSpells: SumSpellsUpdateManyWithoutPlayersNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutGameStatsNestedInput
}

input PlayerStatUpdateManyMutationInput {
  allyTeam: BoolFieldUpdateOperationsInput
  assists: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: FloatFieldUpdateOperationsInput
  deaths: IntFieldUpdateOperationsInput
  kills: IntFieldUpdateOperationsInput
  reduction: FloatFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PlayerStatUpdateManyWithWhereWithoutChampionInput {
  data: PlayerStatUpdateManyMutationInput!
  where: PlayerStatScalarWhereInput!
}

input PlayerStatUpdateManyWithWhereWithoutGameInput {
  data: PlayerStatUpdateManyMutationInput!
  where: PlayerStatScalarWhereInput!
}

input PlayerStatUpdateManyWithWhereWithoutItemsInput {
  data: PlayerStatUpdateManyMutationInput!
  where: PlayerStatScalarWhereInput!
}

input PlayerStatUpdateManyWithWhereWithoutSumSpellsInput {
  data: PlayerStatUpdateManyMutationInput!
  where: PlayerStatScalarWhereInput!
}

input PlayerStatUpdateManyWithWhereWithoutUserInput {
  data: PlayerStatUpdateManyMutationInput!
  where: PlayerStatScalarWhereInput!
}

input PlayerStatUpdateManyWithoutChampionNestedInput {
  connect: [PlayerStatWhereUniqueInput!]
  connectOrCreate: [PlayerStatCreateOrConnectWithoutChampionInput!]
  create: [PlayerStatCreateWithoutChampionInput!]
  createMany: PlayerStatCreateManyChampionInputEnvelope
  delete: [PlayerStatWhereUniqueInput!]
  deleteMany: [PlayerStatScalarWhereInput!]
  disconnect: [PlayerStatWhereUniqueInput!]
  set: [PlayerStatWhereUniqueInput!]
  update: [PlayerStatUpdateWithWhereUniqueWithoutChampionInput!]
  updateMany: [PlayerStatUpdateManyWithWhereWithoutChampionInput!]
  upsert: [PlayerStatUpsertWithWhereUniqueWithoutChampionInput!]
}

input PlayerStatUpdateManyWithoutGameNestedInput {
  connect: [PlayerStatWhereUniqueInput!]
  connectOrCreate: [PlayerStatCreateOrConnectWithoutGameInput!]
  create: [PlayerStatCreateWithoutGameInput!]
  createMany: PlayerStatCreateManyGameInputEnvelope
  delete: [PlayerStatWhereUniqueInput!]
  deleteMany: [PlayerStatScalarWhereInput!]
  disconnect: [PlayerStatWhereUniqueInput!]
  set: [PlayerStatWhereUniqueInput!]
  update: [PlayerStatUpdateWithWhereUniqueWithoutGameInput!]
  updateMany: [PlayerStatUpdateManyWithWhereWithoutGameInput!]
  upsert: [PlayerStatUpsertWithWhereUniqueWithoutGameInput!]
}

input PlayerStatUpdateManyWithoutItemsNestedInput {
  connect: [PlayerStatWhereUniqueInput!]
  connectOrCreate: [PlayerStatCreateOrConnectWithoutItemsInput!]
  create: [PlayerStatCreateWithoutItemsInput!]
  delete: [PlayerStatWhereUniqueInput!]
  deleteMany: [PlayerStatScalarWhereInput!]
  disconnect: [PlayerStatWhereUniqueInput!]
  set: [PlayerStatWhereUniqueInput!]
  update: [PlayerStatUpdateWithWhereUniqueWithoutItemsInput!]
  updateMany: [PlayerStatUpdateManyWithWhereWithoutItemsInput!]
  upsert: [PlayerStatUpsertWithWhereUniqueWithoutItemsInput!]
}

input PlayerStatUpdateManyWithoutSumSpellsNestedInput {
  connect: [PlayerStatWhereUniqueInput!]
  connectOrCreate: [PlayerStatCreateOrConnectWithoutSumSpellsInput!]
  create: [PlayerStatCreateWithoutSumSpellsInput!]
  delete: [PlayerStatWhereUniqueInput!]
  deleteMany: [PlayerStatScalarWhereInput!]
  disconnect: [PlayerStatWhereUniqueInput!]
  set: [PlayerStatWhereUniqueInput!]
  update: [PlayerStatUpdateWithWhereUniqueWithoutSumSpellsInput!]
  updateMany: [PlayerStatUpdateManyWithWhereWithoutSumSpellsInput!]
  upsert: [PlayerStatUpsertWithWhereUniqueWithoutSumSpellsInput!]
}

input PlayerStatUpdateManyWithoutUserNestedInput {
  connect: [PlayerStatWhereUniqueInput!]
  connectOrCreate: [PlayerStatCreateOrConnectWithoutUserInput!]
  create: [PlayerStatCreateWithoutUserInput!]
  createMany: PlayerStatCreateManyUserInputEnvelope
  delete: [PlayerStatWhereUniqueInput!]
  deleteMany: [PlayerStatScalarWhereInput!]
  disconnect: [PlayerStatWhereUniqueInput!]
  set: [PlayerStatWhereUniqueInput!]
  update: [PlayerStatUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PlayerStatUpdateManyWithWhereWithoutUserInput!]
  upsert: [PlayerStatUpsertWithWhereUniqueWithoutUserInput!]
}

input PlayerStatUpdateWithWhereUniqueWithoutChampionInput {
  data: PlayerStatUpdateWithoutChampionInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatUpdateWithWhereUniqueWithoutGameInput {
  data: PlayerStatUpdateWithoutGameInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatUpdateWithWhereUniqueWithoutItemsInput {
  data: PlayerStatUpdateWithoutItemsInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatUpdateWithWhereUniqueWithoutSumSpellsInput {
  data: PlayerStatUpdateWithoutSumSpellsInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatUpdateWithWhereUniqueWithoutUserInput {
  data: PlayerStatUpdateWithoutUserInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatUpdateWithoutChampionInput {
  allyTeam: BoolFieldUpdateOperationsInput
  assists: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: FloatFieldUpdateOperationsInput
  deaths: IntFieldUpdateOperationsInput
  game: GameUpdateOneRequiredWithoutPlayersNestedInput
  items: ItemUpdateManyWithoutPlayersNestedInput
  kills: IntFieldUpdateOperationsInput
  reduction: FloatFieldUpdateOperationsInput
  sumSpells: SumSpellsUpdateManyWithoutPlayersNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutGameStatsNestedInput
}

input PlayerStatUpdateWithoutGameInput {
  allyTeam: BoolFieldUpdateOperationsInput
  assists: IntFieldUpdateOperationsInput
  champion: ChampionUpdateOneRequiredWithoutPlayersNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: FloatFieldUpdateOperationsInput
  deaths: IntFieldUpdateOperationsInput
  items: ItemUpdateManyWithoutPlayersNestedInput
  kills: IntFieldUpdateOperationsInput
  reduction: FloatFieldUpdateOperationsInput
  sumSpells: SumSpellsUpdateManyWithoutPlayersNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutGameStatsNestedInput
}

input PlayerStatUpdateWithoutItemsInput {
  allyTeam: BoolFieldUpdateOperationsInput
  assists: IntFieldUpdateOperationsInput
  champion: ChampionUpdateOneRequiredWithoutPlayersNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: FloatFieldUpdateOperationsInput
  deaths: IntFieldUpdateOperationsInput
  game: GameUpdateOneRequiredWithoutPlayersNestedInput
  kills: IntFieldUpdateOperationsInput
  reduction: FloatFieldUpdateOperationsInput
  sumSpells: SumSpellsUpdateManyWithoutPlayersNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutGameStatsNestedInput
}

input PlayerStatUpdateWithoutSumSpellsInput {
  allyTeam: BoolFieldUpdateOperationsInput
  assists: IntFieldUpdateOperationsInput
  champion: ChampionUpdateOneRequiredWithoutPlayersNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: FloatFieldUpdateOperationsInput
  deaths: IntFieldUpdateOperationsInput
  game: GameUpdateOneRequiredWithoutPlayersNestedInput
  items: ItemUpdateManyWithoutPlayersNestedInput
  kills: IntFieldUpdateOperationsInput
  reduction: FloatFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutGameStatsNestedInput
}

input PlayerStatUpdateWithoutUserInput {
  allyTeam: BoolFieldUpdateOperationsInput
  assists: IntFieldUpdateOperationsInput
  champion: ChampionUpdateOneRequiredWithoutPlayersNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: FloatFieldUpdateOperationsInput
  deaths: IntFieldUpdateOperationsInput
  game: GameUpdateOneRequiredWithoutPlayersNestedInput
  items: ItemUpdateManyWithoutPlayersNestedInput
  kills: IntFieldUpdateOperationsInput
  reduction: FloatFieldUpdateOperationsInput
  sumSpells: SumSpellsUpdateManyWithoutPlayersNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PlayerStatUpsertWithWhereUniqueWithoutChampionInput {
  create: PlayerStatCreateWithoutChampionInput!
  update: PlayerStatUpdateWithoutChampionInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatUpsertWithWhereUniqueWithoutGameInput {
  create: PlayerStatCreateWithoutGameInput!
  update: PlayerStatUpdateWithoutGameInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatUpsertWithWhereUniqueWithoutItemsInput {
  create: PlayerStatCreateWithoutItemsInput!
  update: PlayerStatUpdateWithoutItemsInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatUpsertWithWhereUniqueWithoutSumSpellsInput {
  create: PlayerStatCreateWithoutSumSpellsInput!
  update: PlayerStatUpdateWithoutSumSpellsInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatUpsertWithWhereUniqueWithoutUserInput {
  create: PlayerStatCreateWithoutUserInput!
  update: PlayerStatUpdateWithoutUserInput!
  where: PlayerStatWhereUniqueInput!
}

input PlayerStatWhereInput {
  AND: [PlayerStatWhereInput!]
  NOT: [PlayerStatWhereInput!]
  OR: [PlayerStatWhereInput!]
  allyTeam: BoolFilter
  assists: IntFilter
  champion: ChampionRelationFilter
  championId: IntFilter
  createdAt: DateTimeFilter
  damage: FloatFilter
  deaths: IntFilter
  game: GameRelationFilter
  gameId: IntFilter
  id: IntFilter
  items: ItemListRelationFilter
  kills: IntFilter
  reduction: FloatFilter
  sumSpells: SumSpellsListRelationFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntNullableFilter
}

input PlayerStatWhereUniqueInput {
  id: Int
}

type Query {
  aggregateChampion(cursor: ChampionWhereUniqueInput, orderBy: [ChampionOrderByWithRelationInput!], skip: Int, take: Int, where: ChampionWhereInput): AggregateChampion!
  aggregateChampionStat(cursor: ChampionStatWhereUniqueInput, orderBy: [ChampionStatOrderByWithRelationInput!], skip: Int, take: Int, where: ChampionStatWhereInput): AggregateChampionStat!
  aggregateGame(cursor: GameWhereUniqueInput, orderBy: [GameOrderByWithRelationInput!], skip: Int, take: Int, where: GameWhereInput): AggregateGame!
  aggregateItem(cursor: ItemWhereUniqueInput, orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): AggregateItem!
  aggregatePeriod(cursor: PeriodWhereUniqueInput, orderBy: [PeriodOrderByWithRelationInput!], skip: Int, take: Int, where: PeriodWhereInput): AggregatePeriod!
  aggregatePlayerStat(cursor: PlayerStatWhereUniqueInput, orderBy: [PlayerStatOrderByWithRelationInput!], skip: Int, take: Int, where: PlayerStatWhereInput): AggregatePlayerStat!
  aggregateStat(cursor: StatWhereUniqueInput, orderBy: [StatOrderByWithRelationInput!], skip: Int, take: Int, where: StatWhereInput): AggregateStat!
  aggregateSumSpells(cursor: SumSpellsWhereUniqueInput, orderBy: [SumSpellsOrderByWithRelationInput!], skip: Int, take: Int, where: SumSpellsWhereInput): AggregateSumSpells!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  champion(where: ChampionWhereUniqueInput!): Champion
  championStat(where: ChampionStatWhereUniqueInput!): ChampionStat
  championStats(cursor: ChampionStatWhereUniqueInput, distinct: [ChampionStatScalarFieldEnum!], orderBy: [ChampionStatOrderByWithRelationInput!], skip: Int, take: Int, where: ChampionStatWhereInput): [ChampionStat!]!
  champions(cursor: ChampionWhereUniqueInput, distinct: [ChampionScalarFieldEnum!], orderBy: [ChampionOrderByWithRelationInput!], skip: Int, take: Int, where: ChampionWhereInput): [Champion!]!
  findFirstChampion(cursor: ChampionWhereUniqueInput, distinct: [ChampionScalarFieldEnum!], orderBy: [ChampionOrderByWithRelationInput!], skip: Int, take: Int, where: ChampionWhereInput): Champion
  findFirstChampionStat(cursor: ChampionStatWhereUniqueInput, distinct: [ChampionStatScalarFieldEnum!], orderBy: [ChampionStatOrderByWithRelationInput!], skip: Int, take: Int, where: ChampionStatWhereInput): ChampionStat
  findFirstGame(cursor: GameWhereUniqueInput, distinct: [GameScalarFieldEnum!], orderBy: [GameOrderByWithRelationInput!], skip: Int, take: Int, where: GameWhereInput): Game
  findFirstItem(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): Item
  findFirstPeriod(cursor: PeriodWhereUniqueInput, distinct: [PeriodScalarFieldEnum!], orderBy: [PeriodOrderByWithRelationInput!], skip: Int, take: Int, where: PeriodWhereInput): Period
  findFirstPlayerStat(cursor: PlayerStatWhereUniqueInput, distinct: [PlayerStatScalarFieldEnum!], orderBy: [PlayerStatOrderByWithRelationInput!], skip: Int, take: Int, where: PlayerStatWhereInput): PlayerStat
  findFirstStat(cursor: StatWhereUniqueInput, distinct: [StatScalarFieldEnum!], orderBy: [StatOrderByWithRelationInput!], skip: Int, take: Int, where: StatWhereInput): Stat
  findFirstSumSpells(cursor: SumSpellsWhereUniqueInput, distinct: [SumSpellsScalarFieldEnum!], orderBy: [SumSpellsOrderByWithRelationInput!], skip: Int, take: Int, where: SumSpellsWhereInput): SumSpells
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findManySumSpells(cursor: SumSpellsWhereUniqueInput, distinct: [SumSpellsScalarFieldEnum!], orderBy: [SumSpellsOrderByWithRelationInput!], skip: Int, take: Int, where: SumSpellsWhereInput): [SumSpells!]!
  findUniqueSumSpells(where: SumSpellsWhereUniqueInput!): SumSpells
  game(where: GameWhereUniqueInput!): Game
  games(cursor: GameWhereUniqueInput, distinct: [GameScalarFieldEnum!], orderBy: [GameOrderByWithRelationInput!], skip: Int, take: Int, where: GameWhereInput): [Game!]!
  groupByChampion(by: [ChampionScalarFieldEnum!]!, having: ChampionScalarWhereWithAggregatesInput, orderBy: [ChampionOrderByWithAggregationInput!], skip: Int, take: Int, where: ChampionWhereInput): [ChampionGroupBy!]!
  groupByChampionStat(by: [ChampionStatScalarFieldEnum!]!, having: ChampionStatScalarWhereWithAggregatesInput, orderBy: [ChampionStatOrderByWithAggregationInput!], skip: Int, take: Int, where: ChampionStatWhereInput): [ChampionStatGroupBy!]!
  groupByGame(by: [GameScalarFieldEnum!]!, having: GameScalarWhereWithAggregatesInput, orderBy: [GameOrderByWithAggregationInput!], skip: Int, take: Int, where: GameWhereInput): [GameGroupBy!]!
  groupByItem(by: [ItemScalarFieldEnum!]!, having: ItemScalarWhereWithAggregatesInput, orderBy: [ItemOrderByWithAggregationInput!], skip: Int, take: Int, where: ItemWhereInput): [ItemGroupBy!]!
  groupByPeriod(by: [PeriodScalarFieldEnum!]!, having: PeriodScalarWhereWithAggregatesInput, orderBy: [PeriodOrderByWithAggregationInput!], skip: Int, take: Int, where: PeriodWhereInput): [PeriodGroupBy!]!
  groupByPlayerStat(by: [PlayerStatScalarFieldEnum!]!, having: PlayerStatScalarWhereWithAggregatesInput, orderBy: [PlayerStatOrderByWithAggregationInput!], skip: Int, take: Int, where: PlayerStatWhereInput): [PlayerStatGroupBy!]!
  groupByStat(by: [StatScalarFieldEnum!]!, having: StatScalarWhereWithAggregatesInput, orderBy: [StatOrderByWithAggregationInput!], skip: Int, take: Int, where: StatWhereInput): [StatGroupBy!]!
  groupBySumSpells(by: [SumSpellsScalarFieldEnum!]!, having: SumSpellsScalarWhereWithAggregatesInput, orderBy: [SumSpellsOrderByWithAggregationInput!], skip: Int, take: Int, where: SumSpellsWhereInput): [SumSpellsGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  hello: String!
  item(where: ItemWhereUniqueInput!): Item
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  period(where: PeriodWhereUniqueInput!): Period
  periods(cursor: PeriodWhereUniqueInput, distinct: [PeriodScalarFieldEnum!], orderBy: [PeriodOrderByWithRelationInput!], skip: Int, take: Int, where: PeriodWhereInput): [Period!]!
  playerStat(where: PlayerStatWhereUniqueInput!): PlayerStat
  playerStats(cursor: PlayerStatWhereUniqueInput, distinct: [PlayerStatScalarFieldEnum!], orderBy: [PlayerStatOrderByWithRelationInput!], skip: Int, take: Int, where: PlayerStatWhereInput): [PlayerStat!]!
  stat(where: StatWhereUniqueInput!): Stat
  stats(cursor: StatWhereUniqueInput, distinct: [StatScalarFieldEnum!], orderBy: [StatOrderByWithRelationInput!], skip: Int, take: Int, where: StatWhereInput): [Stat!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

type Stat {
  assists: Int
  champion: ChampionStat
  championStatId: Int
  createdAt: DateTime!
  damage: Int
  deaths: Int
  game: Game
  gameId: Int
  id: Int!
  kda: Int
  kills: Int
  perf: Int
  period: Period
  periodId: Int
  reduction: Int
  updatedAt: DateTime!
  user: User!
  userId: Int!
  xClass: Int
}

type StatAvgAggregate {
  assists: Float
  championStatId: Float
  damage: Float
  deaths: Float
  gameId: Float
  id: Float
  kda: Float
  kills: Float
  perf: Float
  periodId: Float
  reduction: Float
  userId: Float
  xClass: Float
}

input StatAvgOrderByAggregateInput {
  assists: SortOrder
  championStatId: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kda: SortOrder
  kills: SortOrder
  perf: SortOrder
  periodId: SortOrder
  reduction: SortOrder
  userId: SortOrder
  xClass: SortOrder
}

type StatCountAggregate {
  _all: Int!
  assists: Int!
  championStatId: Int!
  createdAt: Int!
  damage: Int!
  deaths: Int!
  gameId: Int!
  id: Int!
  kda: Int!
  kills: Int!
  perf: Int!
  periodId: Int!
  reduction: Int!
  updatedAt: Int!
  userId: Int!
  xClass: Int!
}

input StatCountOrderByAggregateInput {
  assists: SortOrder
  championStatId: SortOrder
  createdAt: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kda: SortOrder
  kills: SortOrder
  perf: SortOrder
  periodId: SortOrder
  reduction: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  xClass: SortOrder
}

input StatCreateInput {
  assists: Int
  champion: ChampionStatCreateNestedOneWithoutUserStatsInput
  createdAt: DateTime
  damage: Int
  deaths: Int
  game: GameCreateNestedOneWithoutStatsInput
  kda: Int
  kills: Int
  perf: Int
  period: PeriodCreateNestedOneWithoutStatsInput
  reduction: Int
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutStatsInput!
  xClass: Int
}

input StatCreateManyChampionInput {
  assists: Int
  createdAt: DateTime
  damage: Int
  deaths: Int
  gameId: Int
  id: Int
  kda: Int
  kills: Int
  perf: Int
  periodId: Int
  reduction: Int
  updatedAt: DateTime
  userId: Int!
  xClass: Int
}

input StatCreateManyChampionInputEnvelope {
  data: [StatCreateManyChampionInput!]!
  skipDuplicates: Boolean
}

input StatCreateManyGameInput {
  assists: Int
  championStatId: Int
  createdAt: DateTime
  damage: Int
  deaths: Int
  id: Int
  kda: Int
  kills: Int
  perf: Int
  periodId: Int
  reduction: Int
  updatedAt: DateTime
  userId: Int!
  xClass: Int
}

input StatCreateManyGameInputEnvelope {
  data: [StatCreateManyGameInput!]!
  skipDuplicates: Boolean
}

input StatCreateManyInput {
  assists: Int
  championStatId: Int
  createdAt: DateTime
  damage: Int
  deaths: Int
  gameId: Int
  id: Int
  kda: Int
  kills: Int
  perf: Int
  periodId: Int
  reduction: Int
  updatedAt: DateTime
  userId: Int!
  xClass: Int
}

input StatCreateManyPeriodInput {
  assists: Int
  championStatId: Int
  createdAt: DateTime
  damage: Int
  deaths: Int
  gameId: Int
  id: Int
  kda: Int
  kills: Int
  perf: Int
  reduction: Int
  updatedAt: DateTime
  userId: Int!
  xClass: Int
}

input StatCreateManyPeriodInputEnvelope {
  data: [StatCreateManyPeriodInput!]!
  skipDuplicates: Boolean
}

input StatCreateManyUserInput {
  assists: Int
  championStatId: Int
  createdAt: DateTime
  damage: Int
  deaths: Int
  gameId: Int
  id: Int
  kda: Int
  kills: Int
  perf: Int
  periodId: Int
  reduction: Int
  updatedAt: DateTime
  xClass: Int
}

input StatCreateManyUserInputEnvelope {
  data: [StatCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input StatCreateNestedManyWithoutChampionInput {
  connect: [StatWhereUniqueInput!]
  connectOrCreate: [StatCreateOrConnectWithoutChampionInput!]
  create: [StatCreateWithoutChampionInput!]
  createMany: StatCreateManyChampionInputEnvelope
}

input StatCreateNestedManyWithoutGameInput {
  connect: [StatWhereUniqueInput!]
  connectOrCreate: [StatCreateOrConnectWithoutGameInput!]
  create: [StatCreateWithoutGameInput!]
  createMany: StatCreateManyGameInputEnvelope
}

input StatCreateNestedManyWithoutPeriodInput {
  connect: [StatWhereUniqueInput!]
  connectOrCreate: [StatCreateOrConnectWithoutPeriodInput!]
  create: [StatCreateWithoutPeriodInput!]
  createMany: StatCreateManyPeriodInputEnvelope
}

input StatCreateNestedManyWithoutUserInput {
  connect: [StatWhereUniqueInput!]
  connectOrCreate: [StatCreateOrConnectWithoutUserInput!]
  create: [StatCreateWithoutUserInput!]
  createMany: StatCreateManyUserInputEnvelope
}

input StatCreateOrConnectWithoutChampionInput {
  create: StatCreateWithoutChampionInput!
  where: StatWhereUniqueInput!
}

input StatCreateOrConnectWithoutGameInput {
  create: StatCreateWithoutGameInput!
  where: StatWhereUniqueInput!
}

input StatCreateOrConnectWithoutPeriodInput {
  create: StatCreateWithoutPeriodInput!
  where: StatWhereUniqueInput!
}

input StatCreateOrConnectWithoutUserInput {
  create: StatCreateWithoutUserInput!
  where: StatWhereUniqueInput!
}

input StatCreateWithoutChampionInput {
  assists: Int
  createdAt: DateTime
  damage: Int
  deaths: Int
  game: GameCreateNestedOneWithoutStatsInput
  kda: Int
  kills: Int
  perf: Int
  period: PeriodCreateNestedOneWithoutStatsInput
  reduction: Int
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutStatsInput!
  xClass: Int
}

input StatCreateWithoutGameInput {
  assists: Int
  champion: ChampionStatCreateNestedOneWithoutUserStatsInput
  createdAt: DateTime
  damage: Int
  deaths: Int
  kda: Int
  kills: Int
  perf: Int
  period: PeriodCreateNestedOneWithoutStatsInput
  reduction: Int
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutStatsInput!
  xClass: Int
}

input StatCreateWithoutPeriodInput {
  assists: Int
  champion: ChampionStatCreateNestedOneWithoutUserStatsInput
  createdAt: DateTime
  damage: Int
  deaths: Int
  game: GameCreateNestedOneWithoutStatsInput
  kda: Int
  kills: Int
  perf: Int
  reduction: Int
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutStatsInput!
  xClass: Int
}

input StatCreateWithoutUserInput {
  assists: Int
  champion: ChampionStatCreateNestedOneWithoutUserStatsInput
  createdAt: DateTime
  damage: Int
  deaths: Int
  game: GameCreateNestedOneWithoutStatsInput
  kda: Int
  kills: Int
  perf: Int
  period: PeriodCreateNestedOneWithoutStatsInput
  reduction: Int
  updatedAt: DateTime
  xClass: Int
}

input StatGameIdentifierCompoundUniqueInput {
  gameId: Int!
  userId: Int!
}

type StatGroupBy {
  _avg: StatAvgAggregate
  _count: StatCountAggregate
  _max: StatMaxAggregate
  _min: StatMinAggregate
  _sum: StatSumAggregate
  assists: Int
  championStatId: Int
  createdAt: DateTime!
  damage: Int
  deaths: Int
  gameId: Int
  id: Int!
  kda: Int
  kills: Int
  perf: Int
  periodId: Int
  reduction: Int
  updatedAt: DateTime!
  userId: Int!
  xClass: Int
}

input StatListRelationFilter {
  every: StatWhereInput
  none: StatWhereInput
  some: StatWhereInput
}

type StatMaxAggregate {
  assists: Int
  championStatId: Int
  createdAt: DateTime
  damage: Int
  deaths: Int
  gameId: Int
  id: Int
  kda: Int
  kills: Int
  perf: Int
  periodId: Int
  reduction: Int
  updatedAt: DateTime
  userId: Int
  xClass: Int
}

input StatMaxOrderByAggregateInput {
  assists: SortOrder
  championStatId: SortOrder
  createdAt: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kda: SortOrder
  kills: SortOrder
  perf: SortOrder
  periodId: SortOrder
  reduction: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  xClass: SortOrder
}

type StatMinAggregate {
  assists: Int
  championStatId: Int
  createdAt: DateTime
  damage: Int
  deaths: Int
  gameId: Int
  id: Int
  kda: Int
  kills: Int
  perf: Int
  periodId: Int
  reduction: Int
  updatedAt: DateTime
  userId: Int
  xClass: Int
}

input StatMinOrderByAggregateInput {
  assists: SortOrder
  championStatId: SortOrder
  createdAt: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kda: SortOrder
  kills: SortOrder
  perf: SortOrder
  periodId: SortOrder
  reduction: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  xClass: SortOrder
}

input StatOrderByRelationAggregateInput {
  _count: SortOrder
}

input StatOrderByWithAggregationInput {
  _avg: StatAvgOrderByAggregateInput
  _count: StatCountOrderByAggregateInput
  _max: StatMaxOrderByAggregateInput
  _min: StatMinOrderByAggregateInput
  _sum: StatSumOrderByAggregateInput
  assists: SortOrder
  championStatId: SortOrder
  createdAt: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kda: SortOrder
  kills: SortOrder
  perf: SortOrder
  periodId: SortOrder
  reduction: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  xClass: SortOrder
}

input StatOrderByWithRelationInput {
  assists: SortOrder
  champion: ChampionStatOrderByWithRelationInput
  championStatId: SortOrder
  createdAt: SortOrder
  damage: SortOrder
  deaths: SortOrder
  game: GameOrderByWithRelationInput
  gameId: SortOrder
  id: SortOrder
  kda: SortOrder
  kills: SortOrder
  perf: SortOrder
  period: PeriodOrderByWithRelationInput
  periodId: SortOrder
  reduction: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
  xClass: SortOrder
}

enum StatScalarFieldEnum {
  assists
  championStatId
  createdAt
  damage
  deaths
  gameId
  id
  kda
  kills
  perf
  periodId
  reduction
  updatedAt
  userId
  xClass
}

input StatScalarWhereInput {
  AND: [StatScalarWhereInput!]
  NOT: [StatScalarWhereInput!]
  OR: [StatScalarWhereInput!]
  assists: IntNullableFilter
  championStatId: IntNullableFilter
  createdAt: DateTimeFilter
  damage: IntNullableFilter
  deaths: IntNullableFilter
  gameId: IntNullableFilter
  id: IntFilter
  kda: IntNullableFilter
  kills: IntNullableFilter
  perf: IntNullableFilter
  periodId: IntNullableFilter
  reduction: IntNullableFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  xClass: IntNullableFilter
}

input StatScalarWhereWithAggregatesInput {
  AND: [StatScalarWhereWithAggregatesInput!]
  NOT: [StatScalarWhereWithAggregatesInput!]
  OR: [StatScalarWhereWithAggregatesInput!]
  assists: IntNullableWithAggregatesFilter
  championStatId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  damage: IntNullableWithAggregatesFilter
  deaths: IntNullableWithAggregatesFilter
  gameId: IntNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  kda: IntNullableWithAggregatesFilter
  kills: IntNullableWithAggregatesFilter
  perf: IntNullableWithAggregatesFilter
  periodId: IntNullableWithAggregatesFilter
  reduction: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
  xClass: IntNullableWithAggregatesFilter
}

type StatSumAggregate {
  assists: Int
  championStatId: Int
  damage: Int
  deaths: Int
  gameId: Int
  id: Int
  kda: Int
  kills: Int
  perf: Int
  periodId: Int
  reduction: Int
  userId: Int
  xClass: Int
}

input StatSumOrderByAggregateInput {
  assists: SortOrder
  championStatId: SortOrder
  damage: SortOrder
  deaths: SortOrder
  gameId: SortOrder
  id: SortOrder
  kda: SortOrder
  kills: SortOrder
  perf: SortOrder
  periodId: SortOrder
  reduction: SortOrder
  userId: SortOrder
  xClass: SortOrder
}

input StatUpdateInput {
  assists: NullableIntFieldUpdateOperationsInput
  champion: ChampionStatUpdateOneWithoutUserStatsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: NullableIntFieldUpdateOperationsInput
  deaths: NullableIntFieldUpdateOperationsInput
  game: GameUpdateOneWithoutStatsNestedInput
  kda: NullableIntFieldUpdateOperationsInput
  kills: NullableIntFieldUpdateOperationsInput
  perf: NullableIntFieldUpdateOperationsInput
  period: PeriodUpdateOneWithoutStatsNestedInput
  reduction: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutStatsNestedInput
  xClass: NullableIntFieldUpdateOperationsInput
}

input StatUpdateManyMutationInput {
  assists: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: NullableIntFieldUpdateOperationsInput
  deaths: NullableIntFieldUpdateOperationsInput
  kda: NullableIntFieldUpdateOperationsInput
  kills: NullableIntFieldUpdateOperationsInput
  perf: NullableIntFieldUpdateOperationsInput
  reduction: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  xClass: NullableIntFieldUpdateOperationsInput
}

input StatUpdateManyWithWhereWithoutChampionInput {
  data: StatUpdateManyMutationInput!
  where: StatScalarWhereInput!
}

input StatUpdateManyWithWhereWithoutGameInput {
  data: StatUpdateManyMutationInput!
  where: StatScalarWhereInput!
}

input StatUpdateManyWithWhereWithoutPeriodInput {
  data: StatUpdateManyMutationInput!
  where: StatScalarWhereInput!
}

input StatUpdateManyWithWhereWithoutUserInput {
  data: StatUpdateManyMutationInput!
  where: StatScalarWhereInput!
}

input StatUpdateManyWithoutChampionNestedInput {
  connect: [StatWhereUniqueInput!]
  connectOrCreate: [StatCreateOrConnectWithoutChampionInput!]
  create: [StatCreateWithoutChampionInput!]
  createMany: StatCreateManyChampionInputEnvelope
  delete: [StatWhereUniqueInput!]
  deleteMany: [StatScalarWhereInput!]
  disconnect: [StatWhereUniqueInput!]
  set: [StatWhereUniqueInput!]
  update: [StatUpdateWithWhereUniqueWithoutChampionInput!]
  updateMany: [StatUpdateManyWithWhereWithoutChampionInput!]
  upsert: [StatUpsertWithWhereUniqueWithoutChampionInput!]
}

input StatUpdateManyWithoutGameNestedInput {
  connect: [StatWhereUniqueInput!]
  connectOrCreate: [StatCreateOrConnectWithoutGameInput!]
  create: [StatCreateWithoutGameInput!]
  createMany: StatCreateManyGameInputEnvelope
  delete: [StatWhereUniqueInput!]
  deleteMany: [StatScalarWhereInput!]
  disconnect: [StatWhereUniqueInput!]
  set: [StatWhereUniqueInput!]
  update: [StatUpdateWithWhereUniqueWithoutGameInput!]
  updateMany: [StatUpdateManyWithWhereWithoutGameInput!]
  upsert: [StatUpsertWithWhereUniqueWithoutGameInput!]
}

input StatUpdateManyWithoutPeriodNestedInput {
  connect: [StatWhereUniqueInput!]
  connectOrCreate: [StatCreateOrConnectWithoutPeriodInput!]
  create: [StatCreateWithoutPeriodInput!]
  createMany: StatCreateManyPeriodInputEnvelope
  delete: [StatWhereUniqueInput!]
  deleteMany: [StatScalarWhereInput!]
  disconnect: [StatWhereUniqueInput!]
  set: [StatWhereUniqueInput!]
  update: [StatUpdateWithWhereUniqueWithoutPeriodInput!]
  updateMany: [StatUpdateManyWithWhereWithoutPeriodInput!]
  upsert: [StatUpsertWithWhereUniqueWithoutPeriodInput!]
}

input StatUpdateManyWithoutUserNestedInput {
  connect: [StatWhereUniqueInput!]
  connectOrCreate: [StatCreateOrConnectWithoutUserInput!]
  create: [StatCreateWithoutUserInput!]
  createMany: StatCreateManyUserInputEnvelope
  delete: [StatWhereUniqueInput!]
  deleteMany: [StatScalarWhereInput!]
  disconnect: [StatWhereUniqueInput!]
  set: [StatWhereUniqueInput!]
  update: [StatUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [StatUpdateManyWithWhereWithoutUserInput!]
  upsert: [StatUpsertWithWhereUniqueWithoutUserInput!]
}

input StatUpdateWithWhereUniqueWithoutChampionInput {
  data: StatUpdateWithoutChampionInput!
  where: StatWhereUniqueInput!
}

input StatUpdateWithWhereUniqueWithoutGameInput {
  data: StatUpdateWithoutGameInput!
  where: StatWhereUniqueInput!
}

input StatUpdateWithWhereUniqueWithoutPeriodInput {
  data: StatUpdateWithoutPeriodInput!
  where: StatWhereUniqueInput!
}

input StatUpdateWithWhereUniqueWithoutUserInput {
  data: StatUpdateWithoutUserInput!
  where: StatWhereUniqueInput!
}

input StatUpdateWithoutChampionInput {
  assists: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: NullableIntFieldUpdateOperationsInput
  deaths: NullableIntFieldUpdateOperationsInput
  game: GameUpdateOneWithoutStatsNestedInput
  kda: NullableIntFieldUpdateOperationsInput
  kills: NullableIntFieldUpdateOperationsInput
  perf: NullableIntFieldUpdateOperationsInput
  period: PeriodUpdateOneWithoutStatsNestedInput
  reduction: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutStatsNestedInput
  xClass: NullableIntFieldUpdateOperationsInput
}

input StatUpdateWithoutGameInput {
  assists: NullableIntFieldUpdateOperationsInput
  champion: ChampionStatUpdateOneWithoutUserStatsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: NullableIntFieldUpdateOperationsInput
  deaths: NullableIntFieldUpdateOperationsInput
  kda: NullableIntFieldUpdateOperationsInput
  kills: NullableIntFieldUpdateOperationsInput
  perf: NullableIntFieldUpdateOperationsInput
  period: PeriodUpdateOneWithoutStatsNestedInput
  reduction: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutStatsNestedInput
  xClass: NullableIntFieldUpdateOperationsInput
}

input StatUpdateWithoutPeriodInput {
  assists: NullableIntFieldUpdateOperationsInput
  champion: ChampionStatUpdateOneWithoutUserStatsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: NullableIntFieldUpdateOperationsInput
  deaths: NullableIntFieldUpdateOperationsInput
  game: GameUpdateOneWithoutStatsNestedInput
  kda: NullableIntFieldUpdateOperationsInput
  kills: NullableIntFieldUpdateOperationsInput
  perf: NullableIntFieldUpdateOperationsInput
  reduction: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutStatsNestedInput
  xClass: NullableIntFieldUpdateOperationsInput
}

input StatUpdateWithoutUserInput {
  assists: NullableIntFieldUpdateOperationsInput
  champion: ChampionStatUpdateOneWithoutUserStatsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  damage: NullableIntFieldUpdateOperationsInput
  deaths: NullableIntFieldUpdateOperationsInput
  game: GameUpdateOneWithoutStatsNestedInput
  kda: NullableIntFieldUpdateOperationsInput
  kills: NullableIntFieldUpdateOperationsInput
  perf: NullableIntFieldUpdateOperationsInput
  period: PeriodUpdateOneWithoutStatsNestedInput
  reduction: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  xClass: NullableIntFieldUpdateOperationsInput
}

input StatUpsertWithWhereUniqueWithoutChampionInput {
  create: StatCreateWithoutChampionInput!
  update: StatUpdateWithoutChampionInput!
  where: StatWhereUniqueInput!
}

input StatUpsertWithWhereUniqueWithoutGameInput {
  create: StatCreateWithoutGameInput!
  update: StatUpdateWithoutGameInput!
  where: StatWhereUniqueInput!
}

input StatUpsertWithWhereUniqueWithoutPeriodInput {
  create: StatCreateWithoutPeriodInput!
  update: StatUpdateWithoutPeriodInput!
  where: StatWhereUniqueInput!
}

input StatUpsertWithWhereUniqueWithoutUserInput {
  create: StatCreateWithoutUserInput!
  update: StatUpdateWithoutUserInput!
  where: StatWhereUniqueInput!
}

input StatWhereInput {
  AND: [StatWhereInput!]
  NOT: [StatWhereInput!]
  OR: [StatWhereInput!]
  assists: IntNullableFilter
  champion: ChampionStatRelationFilter
  championStatId: IntNullableFilter
  createdAt: DateTimeFilter
  damage: IntNullableFilter
  deaths: IntNullableFilter
  game: GameRelationFilter
  gameId: IntNullableFilter
  id: IntFilter
  kda: IntNullableFilter
  kills: IntNullableFilter
  perf: IntNullableFilter
  period: PeriodRelationFilter
  periodId: IntNullableFilter
  reduction: IntNullableFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
  xClass: IntNullableFilter
}

input StatWhereUniqueInput {
  gameIdentifier: StatGameIdentifierCompoundUniqueInput
  id: Int
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type SumSpells {
  _count: SumSpellsCount
  createdAt: DateTime!
  id: Int!
  name: String!
  players(cursor: PlayerStatWhereUniqueInput, distinct: [PlayerStatScalarFieldEnum!], orderBy: [PlayerStatOrderByWithRelationInput!], skip: Int, take: Int, where: PlayerStatWhereInput): [PlayerStat!]!
  updatedAt: DateTime!
}

type SumSpellsAvgAggregate {
  id: Float
}

input SumSpellsAvgOrderByAggregateInput {
  id: SortOrder
}

type SumSpellsCount {
  players: Int!
}

type SumSpellsCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input SumSpellsCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input SumSpellsCreateInput {
  createdAt: DateTime
  name: String!
  players: PlayerStatCreateNestedManyWithoutSumSpellsInput
  updatedAt: DateTime
}

input SumSpellsCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input SumSpellsCreateNestedManyWithoutPlayersInput {
  connect: [SumSpellsWhereUniqueInput!]
  connectOrCreate: [SumSpellsCreateOrConnectWithoutPlayersInput!]
  create: [SumSpellsCreateWithoutPlayersInput!]
}

input SumSpellsCreateOrConnectWithoutPlayersInput {
  create: SumSpellsCreateWithoutPlayersInput!
  where: SumSpellsWhereUniqueInput!
}

input SumSpellsCreateWithoutPlayersInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

type SumSpellsGroupBy {
  _avg: SumSpellsAvgAggregate
  _count: SumSpellsCountAggregate
  _max: SumSpellsMaxAggregate
  _min: SumSpellsMinAggregate
  _sum: SumSpellsSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

input SumSpellsListRelationFilter {
  every: SumSpellsWhereInput
  none: SumSpellsWhereInput
  some: SumSpellsWhereInput
}

type SumSpellsMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input SumSpellsMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type SumSpellsMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input SumSpellsMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input SumSpellsOrderByRelationAggregateInput {
  _count: SortOrder
}

input SumSpellsOrderByWithAggregationInput {
  _avg: SumSpellsAvgOrderByAggregateInput
  _count: SumSpellsCountOrderByAggregateInput
  _max: SumSpellsMaxOrderByAggregateInput
  _min: SumSpellsMinOrderByAggregateInput
  _sum: SumSpellsSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input SumSpellsOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  players: PlayerStatOrderByRelationAggregateInput
  updatedAt: SortOrder
}

enum SumSpellsScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input SumSpellsScalarWhereInput {
  AND: [SumSpellsScalarWhereInput!]
  NOT: [SumSpellsScalarWhereInput!]
  OR: [SumSpellsScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input SumSpellsScalarWhereWithAggregatesInput {
  AND: [SumSpellsScalarWhereWithAggregatesInput!]
  NOT: [SumSpellsScalarWhereWithAggregatesInput!]
  OR: [SumSpellsScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type SumSpellsSumAggregate {
  id: Int
}

input SumSpellsSumOrderByAggregateInput {
  id: SortOrder
}

input SumSpellsUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  players: PlayerStatUpdateManyWithoutSumSpellsNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SumSpellsUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SumSpellsUpdateManyWithWhereWithoutPlayersInput {
  data: SumSpellsUpdateManyMutationInput!
  where: SumSpellsScalarWhereInput!
}

input SumSpellsUpdateManyWithoutPlayersNestedInput {
  connect: [SumSpellsWhereUniqueInput!]
  connectOrCreate: [SumSpellsCreateOrConnectWithoutPlayersInput!]
  create: [SumSpellsCreateWithoutPlayersInput!]
  delete: [SumSpellsWhereUniqueInput!]
  deleteMany: [SumSpellsScalarWhereInput!]
  disconnect: [SumSpellsWhereUniqueInput!]
  set: [SumSpellsWhereUniqueInput!]
  update: [SumSpellsUpdateWithWhereUniqueWithoutPlayersInput!]
  updateMany: [SumSpellsUpdateManyWithWhereWithoutPlayersInput!]
  upsert: [SumSpellsUpsertWithWhereUniqueWithoutPlayersInput!]
}

input SumSpellsUpdateWithWhereUniqueWithoutPlayersInput {
  data: SumSpellsUpdateWithoutPlayersInput!
  where: SumSpellsWhereUniqueInput!
}

input SumSpellsUpdateWithoutPlayersInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SumSpellsUpsertWithWhereUniqueWithoutPlayersInput {
  create: SumSpellsCreateWithoutPlayersInput!
  update: SumSpellsUpdateWithoutPlayersInput!
  where: SumSpellsWhereUniqueInput!
}

input SumSpellsWhereInput {
  AND: [SumSpellsWhereInput!]
  NOT: [SumSpellsWhereInput!]
  OR: [SumSpellsWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  players: PlayerStatListRelationFilter
  updatedAt: DateTimeFilter
}

input SumSpellsWhereUniqueInput {
  id: Int
  name: String
}

type User {
  _count: UserCount
  createdAt: DateTime!
  gameStats(cursor: PlayerStatWhereUniqueInput, distinct: [PlayerStatScalarFieldEnum!], orderBy: [PlayerStatOrderByWithRelationInput!], skip: Int, take: Int, where: PlayerStatWhereInput): [PlayerStat!]!
  id: Int!
  ign: String
  lolId: String
  name: String!
  stats(cursor: StatWhereUniqueInput, distinct: [StatScalarFieldEnum!], orderBy: [StatOrderByWithRelationInput!], skip: Int, take: Int, where: StatWhereInput): [Stat!]!
  updatedAt: DateTime!
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCount {
  gameStats: Int!
  stats: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  ign: Int!
  lolId: Int!
  name: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  ign: SortOrder
  lolId: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  createdAt: DateTime
  gameStats: PlayerStatCreateNestedManyWithoutUserInput
  ign: String
  lolId: String
  name: String!
  stats: StatCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateManyInput {
  createdAt: DateTime
  id: Int
  ign: String
  lolId: String
  name: String!
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutGameStatsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutGameStatsInput
  create: UserCreateWithoutGameStatsInput
}

input UserCreateNestedOneWithoutStatsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutStatsInput
  create: UserCreateWithoutStatsInput
}

input UserCreateOrConnectWithoutGameStatsInput {
  create: UserCreateWithoutGameStatsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutStatsInput {
  create: UserCreateWithoutStatsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutGameStatsInput {
  createdAt: DateTime
  ign: String
  lolId: String
  name: String!
  stats: StatCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutStatsInput {
  createdAt: DateTime
  gameStats: PlayerStatCreateNestedManyWithoutUserInput
  ign: String
  lolId: String
  name: String!
  updatedAt: DateTime
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  createdAt: DateTime!
  id: Int!
  ign: String
  lolId: String
  name: String!
  updatedAt: DateTime!
}

type UserMaxAggregate {
  createdAt: DateTime
  id: Int
  ign: String
  lolId: String
  name: String
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  ign: SortOrder
  lolId: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  id: Int
  ign: String
  lolId: String
  name: String
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  ign: SortOrder
  lolId: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  ign: SortOrder
  lolId: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  createdAt: SortOrder
  gameStats: PlayerStatOrderByRelationAggregateInput
  id: SortOrder
  ign: SortOrder
  lolId: SortOrder
  name: SortOrder
  stats: StatOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  id
  ign
  lolId
  name
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  ign: StringNullableWithAggregatesFilter
  lolId: StringNullableWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  gameStats: PlayerStatUpdateManyWithoutUserNestedInput
  ign: NullableStringFieldUpdateOperationsInput
  lolId: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  stats: StatUpdateManyWithoutUserNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  ign: NullableStringFieldUpdateOperationsInput
  lolId: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutStatsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutStatsInput
  create: UserCreateWithoutStatsInput
  update: UserUpdateWithoutStatsInput
  upsert: UserUpsertWithoutStatsInput
}

input UserUpdateOneWithoutGameStatsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutGameStatsInput
  create: UserCreateWithoutGameStatsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutGameStatsInput
  upsert: UserUpsertWithoutGameStatsInput
}

input UserUpdateWithoutGameStatsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  ign: NullableStringFieldUpdateOperationsInput
  lolId: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  stats: StatUpdateManyWithoutUserNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutStatsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  gameStats: PlayerStatUpdateManyWithoutUserNestedInput
  ign: NullableStringFieldUpdateOperationsInput
  lolId: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutGameStatsInput {
  create: UserCreateWithoutGameStatsInput!
  update: UserUpdateWithoutGameStatsInput!
}

input UserUpsertWithoutStatsInput {
  create: UserCreateWithoutStatsInput!
  update: UserUpdateWithoutStatsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  gameStats: PlayerStatListRelationFilter
  id: IntFilter
  ign: StringNullableFilter
  lolId: StringNullableFilter
  name: StringFilter
  stats: StatListRelationFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  id: Int
  ign: String
  lolId: String
  name: String
}
